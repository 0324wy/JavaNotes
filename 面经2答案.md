# 面经2答案

## MySQL

### 1、事务4大特性，一致性具体指什么？这4个特性mysql如何保证实现的？ 

​    事务相关

数据库的事务

  事务：一组数据库操作，要么全都执行，要么都不执行;

  事务特性：ACID. 原子性：事务是最小的执行单位，不可分割，保证事务要么都完成，要么都不完成。

一致性：？？？执行事务前后，数据保持一致。隔离性：并发访问数据库时：一个事务不被其他事务干扰。持久性：事务一  旦提交，对数据库的改变是持久的

并发事务带来的问题：

脏读：一个事务读取了另一个事务修改但未提交的数据。

丢失修改：数据被两个事务连续修改，第一个事务的修改丢失了。

  不可重复读，一个事务连续读两次数据，但结果不一样。(两次读之间，数据被其他事务修改)。

幻读：一个事务连续读两次数据，读取数据量不一样。(两次读之前，数据被其他事务删除或新增)。



### 2、事务隔离级别，4个隔离级别分别有什么并发问题？

### 3、Mysql默认隔离级别？如何保证并发安全？

事务隔离级别:

 1、读未提交。可以读取尚未提交的数据。能导致脏读，不可重复读，幻读。

   2、读已提交。允许读取并发事务已经提交的数据。导致不可重复读，幻读。

3、可重复读。意义在哪？？？？对同一字段，多次读取结果一致。导致幻读。

不可重复读很容易让人陷入一个思维定式那就是 我干嘛需要多次读取一个值还要保证一致

要跳出这个思维看本质：我在事务中会不会受到其他事务的影响？

举个简单的例子 数据校对（只是举个例子体现意思 不用太在意具体的业务）

我要取当前的余额 当前的账单 上个月的余额 我要检验一下数据对不对

我在事务中取了当前的账单和上个月的余额，好嘛，这时候又有新的订单提交了，我再获取余额是不是就不一致了？

   4、串行化。所有事务，依次执行。没啥问题。（这个串行化是针对行锁的，不同行的事务可以并发）

​    设置隔离级别之后，并不是不能并发，而是并发的时候，一个事务的修改数据(绝对读到，提交的才能读到。提交不提交，更新的数据都读不到。提交不提交，增删的数据都读不到)，什么时候才能被另一个事务读到。但彼此的逻辑操作没有影响。

​    MySQL InnoDB默认支持可重复读，但使用了Next-Key Lock算法避免了幻读的发生。完全达到了保保证事务的隔离要求。但在分布式事务下，一般可串行化。



### 6、存储引擎Innodb和Myisam的区别以及使用场景 

Innodb和Myisam的区别：

  1、MyISAM不支持事务，而Innodb支持事务。2、Myisam是表级锁，而Innodb是行级锁。3外键支持：mysiam表不支持外键，而InnoDB支持。4、count运算：myisam缓存有表的行数，这种缓存只是表行的总数，where筛选无效。而Innodb没有。

  MyISAM适合：(1)做很多count 的计算；(2)读密集；(3)没有事务。

InnoDB适合：(1)要求事务；(2)写密集（3）高并发



### 7、 介绍Inodb锁机制，行锁，表锁，意向锁 

三种并发控制机制：悲观并发控制、乐观并发控制和多版本并发控制。悲观并发控制其实是最常见的并发控制机制，也就是锁；乐观并发控制其实也有另一个名字：乐观锁. MVCC多版本并发控制机制，可以与前两者中的任意一种机制结合使用，以提高数据库的读性能。

​    乐观锁：在访问数据之前，默认不会有其他事务对此数据进行修改，所以先访问数据，然后再查找在此期间是否有事务修改数据。这不是数据库自带的，需要我们自己去实现，一般基于版本去实现。

​    悲观锁：

​    按照锁的粒度把数据库锁分为表级锁和行级锁。

​    表级锁: 对当前操作的整张表加锁,实现简单，加锁快，不死锁，但并发能力低。

​    行级锁: 只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

​    Record Lock记录锁: 锁住某一行，如果表存在索引，那么记录锁是锁在索引上的，如果表没有索引，那么 InnoDB 会创建一个隐藏的聚簇索引加锁。

​    Gap LocK间隙锁: 间隙锁是一种记录行与记录行之间存在空隙或在第一行记录之前或最后一行记录之后产生的锁。间隙锁可能占据的单行，多行或者是空记录。 对索引项之间的“间隙”加锁，锁定记录的范围,不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。

​    Next-key Lock： 锁定索引项本身和索引范围。NK 是一种记录锁和间隙锁的组合锁。既锁住行也锁住间隙。即Record Lock和Gap Lock的结合。可解决幻读问题。

​    根据是否独占，锁又可以分为共享锁和排他锁。

​    共享锁（Share Locks，简记为S）又被称为读锁，其他用户可以并发读取数据，但任何事务都不能获取数据上的排他锁，直到已释放所有共享锁。

​    排它锁（(Exclusive lock,简记为X锁)）又称为写锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。

​    Innodb同时支持行锁和表锁。但行锁和表锁的同时存在会发生冲突，如A申请了行共享锁，而B再申请表互斥锁。这时B不仅需要查看是否已经存在其他表锁，以及逐个查看是否存在行锁，效率太低。于是又引入了意向锁。意向锁是一种表级锁，用来指示接下来的一个事务将要获取的是什么类型的锁（共享还是独占）。意向锁分为意向共享锁（IS）和意向独占锁（IX），依次表示接下来一个事务将会获得共享锁或者独占锁。

意向共享锁（IS）：事务打算给数据行加共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。

意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。而事务B发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞。

而且，申请意向锁的动作是数据库自动完成的，不需要我们手动申请。



### 8、介绍MVCC. 

MVCC多版本并发控制（Multiversion Concurrency Control），多版本控制: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。

​    每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回；在这时，读写操作之间的冲突就不再需要被关注，而管理和快速挑选数据的版本就成了 MVCC 需要解决的主要问题。

​    各数据库中MVCC实现并不统一，MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;

对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：(trx_id事务ID、roll_pointer上个版本指针,其实还有一个row_id的隐藏列但这里用不着); 

每次对记录进行改动，都会把对应的事务id赋值给trx_id隐藏列，也会把旧的版本写入到undo日志中；

所以在并发情况下，一个记录可能存在多个版本，通过roll_pointer形成一个版本链。MVCC的核心任务就是：判断一下版本链中的哪个版本是当前事务可见的。这就有了ReadView的概念，这个ReadView中主要包含当前系统中还有哪些活跃的读写事务，把它们的事务id放到一个列表中，我们把这个列表命名为为m_ids；根据ReadView的活跃事务ID列表和版本链事务ID进行比较找出可见的事务ID最大的版本：

1、如果版本的trx_id属性值小于m_ids列表中最小的事务id，表明生成该版本的事务在生成ReadView前已经提交，所以该版本可以被当前事务访问。

2、如果版本的trx_id属性值大于m_ids列表中最大的事务id，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。

3、被访问版本的trx_id属性值在m_ids列表中最大的事务id和最小事务id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。

MVCC只在读已提交和可重复读这两个隔离机制下运行。这两个隔离机制下MVCC实现方式的区别就在于：读已提交是每次读取数据前都生成一个ReadView；而可重复读，是在第一次读取数据时生成一个ReadView，后序的重复查询就不再生产ReadView了。

​    总结：

​    多版本并发控制指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复这个ReadView就好了。



### 9、哈希索引是如何实现的？ 
​    哈希索引基于哈希表实现，只有精确匹配索引的所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。哈希索引对于单行查询有明显的优势，局限见下一问题。

### 10、B树索引为什么使用B+树，相对于B树有什么优点？为什么不能红黑树？要提到磁盘预读 

索引优缺点：(1) 优点：加快检索速度(2)缺点：(a)创建索引和维护索引需要耗费时间(b)索引需要占用空间 (c)进行数据的增删改时候需要动态维护索引

​    索引类型：主键索引，唯一索引，全文索引，普通索引，复合索引。

​    哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。但是有缺点。1、不能使用范围查询。2、无法利用索引的数据来避免任何排序运算；3、不支持多列联合索引的最左匹配规则；4、任何时候都不能避免表扫描。5、存在所谓的哈希碰撞问题。

​    所以我们都用B+树，只有叶子节点存储数据，其他的节点只是起到索引的作用。平衡，性能稳定，每次查询的次数都是树的高度。

​    索引是一种数据结构。索引本身很大，不可能全部存储在内存中，因此索引以索引表的形式存储在磁盘中。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。

​    M阶B树：

1、 树中每个结点至多有m个子结点（即M阶）； 

2、 若根结点不是叶子结点,则至少有2个子结点；

3、 除根结点和叶子结点外,其它每个结点至少有ceil(m/2)个子结点；即中间节点最少有ceil(m/2)个子结点。

4、 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息；

5、 有k个子结点的非终端结点恰好包含有k-1个关键字(单节点里元素).

每个节点中元素个数n必须满足： [ceil(m / 2)-1]<= n <= m-1。(即M阶树单节点最多有M-1个元素)

每个结点中关键字从小到大排列，并且当该结点的孩子是非叶子结点时，该k-1个关键字正好是k个孩子包含的关键字的值域的分划.

​    B+树的不同之处：非叶子节点只存储键值信息。数据记录都存放在叶子节点中。所有叶子节点之间都有一个链指针。

B+树的优点：

​    1、B+树中间节点不存放数据，所以同样大小的磁盘页上可以容纳更多节点元素，IO次数更少。

​    2、B+树的查询必须最终找到叶子节点，而B-树只需要找到匹配的元素即可。B+树性能稳定。

​    3、范围查询方便。B-树只能依靠繁琐的中序遍历，而B+树只需要在链表上遍历即可。

磁盘数据地址：柱面号、盘面号、块号

因为普通的全表查询时间复杂度是O(n);如果是平衡二叉树，或者红黑树，查找时间变成O(log2N)，但他们依然不适合做索引。因为索引通常比较大，存于磁盘中，无法一次将全部的索引加载到内存中，每次只能从磁盘中读取一个页到内存中，而平衡二叉树底层实现是数组，逻辑上相邻的节点在物理结构上可能相差很远，因此磁盘IO次数可能很大，平衡二叉树没能充分利用磁盘预读功能。磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理。红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。 

B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。

logm(n+1)<= h <=log(ceil(m/2)) (n+1)/2 + 1

B+树的关键字全部存放在叶子节点中，非叶子节点用来做索引，而叶子节点中有一个指针指向一下个叶子节点。做这个优化的目的是为了提高区间访问的性能。而正是这个特性决定了B+树更适合用来存储外部数据。

二叉查找树BST：查找最好时间复杂度O(logN)，最坏时间复杂度O(N)。插入删除的实现简单，时间复杂度一致。

平衡二叉查找树AVL：查找的时间复杂度维持在O(logN)，不会出现最差情况 .AVL树在执行每个插入操作时最多需要1次旋转，其时间复杂度在O(logN)左右。 AVL树在执行删除时代价稍大，一次删除操作最多需要O(logN)次旋转,执行每个删除操作的时间复杂度需要O(2logN)。

查找 效率最好情况下时间复杂度为O(logN).

插入和删除操作改变树的平衡性的概率要远远小于AVL（RBT不是高度平衡的）。因此需要的旋转操作的可能性要小，而且一旦需要旋转，插入一个结点最多只需要旋转2次，删除最多只需要旋转3次(小于AVL的删除操作所需要的旋转次数)。虽然变色操作的时间复杂度在O(logN)，但是实际上，这种操作由于简单所需要的代价很小。



### 11、聚簇索引和非聚簇索引区别 

聚簇索引的解释是:聚簇索引的顺序就是数据的物理存储顺序；

​    非聚簇索引的解释是:索引顺序与数据物理排列顺序无关；

   MyISAM使用的是非聚簇索引：非聚簇索引的数据表和索引表是分开存储的。主索引和辅助索引几乎是一样的，叶子节点存储的是指向数据的物理地址。

​    Innodb使用的是聚簇索引。聚簇索引的主键索引的叶子结点存储的是键值对应的数据本身，辅助索引的叶子结点存储的是键值对应的数据的主键键值。

​     B+树有主键索引和辅助索引两种；；主键索引就是按照表中主键的顺序构建一颗B+树，并在叶节点中存放表中的行记录数据，一个表只能有一个主键索引。而辅助索引，叶节点并不存储行记录数据，仅仅是主键。通过辅助索引查找到对应的主键，最后在聚集索引中使用主键获取对应的行记录。（这个叫回表查询？？?）





### 12、回表查询和覆盖索引 

覆盖索引：

​    如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称 之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次,这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！InnoDB存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。SQL只需要通过索引就可以返回查询所需要的数据，而不必通过二级索引查到主键之后再去查询数据。

解释一： 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。

解释二： 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。

解释三：是非聚集组合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段，也即，索引包含了查询正在查找的所有数据）。

 

聚集索引：

​    聚集索引就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据。

辅助索引：

​    辅助索引，也叫非聚集索引。和聚集索引相比，叶子节点中并不包含行记录的全部数据。



### 15、Explain语句各字段的意义 

ID: SELECT的查询序列号;

​    select_type:示查询中每个select子句的类型

(1) SIMPLE(简单SELECT，不使用UNION或子查询等)

(2) PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)

(3) UNION(UNION中的第二个或后面的SELECT语句)

(4) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)

(5) UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)

(6) SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)

(7) DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)

(8) DERIVED(派生表的SELECT, FROM子句的子查询)

(9) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)

​    Table:显示这一步所访问数据库中表名称,

Type对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。

ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）

All:全表扫描。index: full index scan,遍历索引树。range:只检索给定范围的行，使用一个索引来选择行

ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件

const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system

 

NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。

possible_keys：指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用

Key：显示MySQL实际决定使用的键（索引），必然包含在possible_keys中

key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）

ref：列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

rows：估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数、

xtra: 含MySQL解决查询的详细信息,有以下几种情况：

Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤

Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by

Using filesort：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”

Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。

Impossible where：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。

Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行

No tables used：Query语句中使用from dual 或不含任何from子句



### 16、最左前缀！！联合索引B+树是如何建立的？是如何查询的？当where子句中出现>时，联合索引命中是如何的? 如 where a > 10 and b = “111”时，联合索引如何创建？mysql优化器会针对得做出优化吗？  

最左前缀原则：mysql索引可以引用多列，叫联合索引，如果查询条件精确匹配联合索引的左边连续一列或者多列，则查询命中索引。a,b,c的联合索引，(a,c)可以命中a,c不能命中。

联合索引并不是全部不中，或者全部中。可以只命中一部分，例如单单命中A.

MySQL 的查询优化器会自动调整 where 子句的条件顺序以使用适合的索引，不过建议 where 后的字段顺序和联合索引保持一致，养成好习惯。

 

组合索引(大于等于2小于等于3)也是建立一个B+树，只不过非叶子节点存储的是第一个列。叶子节点组合的列都有，中了第一列之后，然后安装其他的列索引搜查。

联合索引的好处：利用覆盖索引，避免回表操作。

而且对于两个单列查询返回行较多，同时查返回行较少，联合索引更高效。





### 17、MySQL中一条SQL语句的执行过程 

​    查询sql的执行语句：

1、客户端通过TCP连接发送连接请求到mysql连接器，连接器会对该请求进行权限验证及连接资源分配。

2、建立连接后客户端发送一条语句，mysql收到该语句后，通过命令分发器判断其是否是一条select语句，如果是，在开启查询缓存的情况下，先在查询缓存中查找该SQL是否完全匹配，如果完全匹配，验证当前用户是否具备查询权限，如果权限验证通过，直接返回结果集给客户端，该查询也就完成了。如果不匹配继续向下执行。

3、如果在查询缓存中未匹配成功，则将语句交给分析器作语法分析，MySQL需要知道到底要查哪些东西，如果语法不对，就会返回语法错误中断查询。

4、分析器的工作完成后，将语句传递给预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义等。

5、语句解析完成后，MySQL就知道要查什么了，之后会将语句传递给优化器进行优化（通过索引选择最快的查找方式），并生成执行计划。

6、之后交给执行器去具体执行该语句，在执行之前，会先检查该用户是否具有查询权限，如果有，继续执行该语句。执行器开始执行后，会逐渐将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。



### 18、数据库几大范式 

 数据库范式：1NF:每个关系的属性都是原子的，不可能分割。每一个列只有一个值。

​    2NF: 如果关系模式R是1NF，且每一个非主属性完全依赖(而不能部分依赖)于候选建，那么就称R是第二范式。

​    3NF：如果关系模式R是2NF，且关系模式R（U,F）中的所有非主属性对任何候选关键字都不存在传递依赖，则称关系R是属于第三范式。

​    BCNF: BC范式（BCNF）：符合3NF，并且，主属性不依赖于主属性





### 19、数据库基本查询关键字使用，如left join on,where,beteen and,group by,having,limit,聚合函数等。 

group by语法可以根据给定数据列的每个成员对查询结果进行分组统计，最终得到一个分组汇总表。

SELECT DEPT, MAX(SALARY) AS MAXIMUM FROM STAFF GROUP BY DEPT ：每个部分的最高薪水

 

SELECT DEPT, sum( SALARY ) AS total FROM STAFF GROUP BY DEPT，每个部门的总薪水

 

having字句可以让我们筛选成组后的各种数据，where字句在聚合前先筛选记录，也就是说作用在group by和having字句前。而 having子句在聚合后对组记录进行筛选。我的理解就是真实表中没有此数据，这些数据是通过一些函数生存。

SELECT region, SUM(population), SUM(area) FROM bbc GROUP BY region HAVING SUM(area)>1000000

SELECT DEPT, MAX( SALARY ) AS MAXIMUM, MIN( SALARY ) AS MINIMUM FROM staff GROUP BY DEPT

HAVING COUNT( * ) >2 ORDER BY DEPT

 

查询最近N天(不超过30天)某一款产品的订单。从第10条开始取5条，ID从大到小倒序。

select * from table limit 9,5;#从0开始

写代码 创建索引

CREATE (UNIQUE/FULLTEXT/) INDEX indexName ON mytable(username(length)); 

ALTER table tableName ADD INDEX indexName(columnName)

CREATE TABLE mytable( 

ID INT NOT NULL,  

username VARCHAR(16) NOT NULL, 

INDEX [indexName] (username(length)) );



### 20、left join,right join,inner join,outer join的含义及区别 

​    内连接NNER JOIN：内连接是一种一一映射关系，就是两张表都有的才能显示出来

​    左连接LEFT JOIN: 左连接是左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分只能补空显示.

​    右连接RIGHT JOIN:右连接，右边表的所有数据都会显示出来，左边的只会出现共同的那部分，其他的空。

​    全连接、外连接Outer Join : 查询出左表和右表所有数据，但是去除两表的重复数据



### 21、mysql主从复制过程，binlog记录格式，复制的异步半同步同步模式区别 

### 22、主从复制或读写分离等数据不一致性问题以及如何解决 

主从复制架构相关

数据库主从复制：

复制的用途：1、读写分离，提供数据库性能和并发能力。2、实时备灾，用于故障切换。

复制存在的问题：1、主库宕机后，数据可能丢失。2、主库写压力大时，复制可能延时。复制延迟怎么解决？？？

复制原理：主从复制是myql内带功能，是一个异步的过程，把主库的二进制日志文件binlog,复制到从库上，然后从库在本地完全顺序的执行日志中的各种操作。

复制过程：1、主节点log dump线程：当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。2、从节点I/O线程：当从节点上执行`start slave`命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点bin log dump 进程发来的更新之后，保存在本地relay-log中。3、从节点SQL线程：SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。

 

从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position；从节点的I/O进程接收到内容后，将接收到的日志内容更新到本机的relay log中，并将读取到的binary log文件名和位置保存到master-info 文件中，Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。

MySQL 主从复制默认是异步的模式：

异步复制：主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理；主节点不会主动push bin log到从节点；

半同步模式：这种模式下主节点只需要接收到其中一台从节点的返回信息，就会commit；否则需要等待直到超时时间然后切换成异步模式再提交；这样做的目的可以使主从数据库的数据延迟缩小，可以提高数据安全性。半同步模式不是mysql内置的，需要装插件开启半同步模式。

全同步模式：全同步模式是指主节点和从节点全部执行了commit并确认才会向客户端返回成功。

binlog记录格式：1、基于SQL语句的复制：记录会修改数据的sql语句到binlog中，减少了binlog日志量，节约IO,提高性能。某些情况：会导致主从节点中数据不一致。2、基于行的复制：将SQL语句分解为基于Row更改的语句并记录在bin log中，也就是只记录哪条数据被修改了，修改成什么样。优点：解决了特定情况下的存储过程、或者函数、或者trigger的调用或者触发无法被正确复制的问题。缺点日志量太大。3、混合方式：能语句就语句，不能语句就切换行。

 

数据库用到了读写分离，那你知不知道这样做会有什么问题：

在从库上会读到系统的一个过期状态”的现象，暂且称之为“过期读”。

强制走主库方案其实就是，将查询请求做分类，对于必须要拿到最新结果的请求，强制将其发到主库上。

sleep 方案：主库更新后，读从库之前先 sleep 一下。具体的方案就是，类似于执行一条 select sleep(1) 命令。

 

mysql主从复制存在的问题：

​    主库宕机后，数据可能丢失

​    从库只有一个sql Thread，主库写压力大，复制很可能延时

解决方法：

​    半同步复制—解决数据丢失的问题

​    并行复制—-解决从库复制延迟的问题（并行是指从库多线程apply binlog库级别并行应用binlog，同一个库数据更改还是串行的(5.7版并行复制基于事务组)设置）

 

 

Mysql逻辑架构可以分为两层：服务层和存储引擎。服务层：Mysql的核心服务功能，查询语句解析，缓存，词法语法分析。



---

#### Mysql死锁处理方式1、等待，直到超时，事务自动回滚。2、发起死锁检测， 回滚一个事务，让其他事务执行。

死锁检测，构建一个以事务为起点，锁为边的有向图，看是否存在环。



#### 其他优化地方：

强制类型转换会全表扫描。Varchar 的 phone = ‘123344’，别用 123345数字。

**使用短索引（又叫前缀索引）来优化索引。**

存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。范围列可以用到索引（联合索引必须是最左前缀），但是范围列后面的列无法用到索引，索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引。

利用覆盖索引来进行查询操作，避免回表。



#### 什么时候要使用索引？

​    主键自动建立唯一索引；

​    经常作为查询条件在WHERE或者ORDER BY 语句中出现的列要建立索引；

​    作为排序的列要建立索引；(单纯的order by 不会用到索引，但如果在where中出现，就可以用索引了。)

​    查询中与其他表关联的字段，外键关系建立索引

​    高并发条件下倾向组合索引；

​    用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引

什么时候不要使用索引？

​    经常增删改的列不要建立索引；

​    有大量重复的列不建立索引；

​    表记录太少不要建立索引。只有当 数据库里已经有了足够多的测试数据时，它的性能测试结果才有实际参考价值。如果在测试数据库里只有几百条数据记录，它们往往在执行完第一条查询命令之后就被全部加载到内存里，这将使后续的查询命令都执行得非常快--不管有没有使用索引。只有当数据库里的记录超过了1000条、数据总量也超过了MySQL服务器上的内存总量时，数据库的性能测试结果才有意义。



#### SQL优化的一些部分：

  如何避免全表扫描？

  1、where字句别用or链接，可以union all.2、in和not in也慎用，可以between and. 3.避免对字段进行null值判断。4,where字句别用!=和<>操作符5、别用以通配符开头的like的查询。6、别在where子句对字段进行表达式操作和函数操作。 7任何地方都不要使用 select * from t。8、尽量使用数字型字段。9、复合索引尽量满足最左前缀原则。10,在查找唯一一条数据的时候，使用limit 1.10、类型不一致会导致失效，例如字符串不加单引号会导致索引失效。

​    索引优化：

​    1、根据最左前缀原则，我们一般把排序分组频率最高的列放在最左边

​    2、模糊查询以%为开始的查询，只能使用全文索引来进行优化。

​    3、使用短索引。对串列进行索引，如果可能应该指定一个前缀长度。

 

in与exists的区别。使用上，in 后面的查询返回结果只能有一个字段。而exists没有限制。

  本质上： A exists B;exists相当于遍历外面A,看A中数据是否存在于B。而in,相当于将结果集B分解开，用or相连，相当于做多次的查询。

  exists相当于查询筛选，in则是多次查询;

  1、如果查询的两个表大小相当，那么用in和exists差别不大。

  2、如果两个表中一个表大，另一个是表小，那么IN适合于外表大而子查询表小的情况。

  3、如果两个表中一个表大，另一个是表小，EXISTS适合于外表小而子查询表大的情况。

  in不会使用索引搜索，会全表扫描。

 

数据量过大：

  1、查询时限定数据范围。2、读写分离，主写从读。3、垂直分区4、水平分区.



#### 数据库相关操作语句

​    数据库范式：1NF:每个关系的属性都是原子的，不可能分割。每一个列只有一个值。

​    2NF: 如果关系模式R是1NF，且每一个非主属性完全依赖(而不能部分依赖)于候选建，那么就称R是第二范式。

​    3NF：如果关系模式R是2NF，且关系模式R（U,F）中的所有非主属性对任何候选关键字都不存在传递依赖，则称关系R是属于第三范式。

​    BCNF: BC范式（BCNF）：符合3NF，并且，主属性不依赖于主属性

​    













## 计算机网络

### 1、OSI七层模型与TCP/IP 五层模型,

网络模型与相关协议**：

​    OSI七层模型:物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层。

​    TCP/IP5层模型：物理层，数据链路层，网络层，运输层，应用层。

​    TCP/IP4层模型：网络接口层，网络层(IP)，运输层(TCP/UDP)，应用层(HTTP)。

常见应用层协议：DNS，HTTP, SMTP, POP3(接受文件)，FTP,Telent远程终端协议。

传输层：TCP，UDP; 网络层：ICMP,IGMP，IP

可以这样做，在OSI模型中ARP协议属于链路层；而在TCP/IP模型中，ARP协议属于网络层。

ARP是IP地址解析为MAC地址 RARP 将MAC地址解析为IP地址

关于TCP协议建立和拥塞控制

### 3、TCP与UDP区别和应用场景，基于TCP的协议有哪些，基于UDP的有哪些？

TCP提供可靠的、面向连接的运输服务。在传输数据之前必须三次握手建立连接，数据传输结束之后，4次挥手释放连接，而且在数据传递时，又有确认应答、超时重传、滑动窗口、拥塞控制等机制保证传送数据的可靠性。TCP经常用于对网络通信质量有很高要求的地方，如文件传输，邮件发送，远程登录等场景。SMTP、TELNET、HTTP、FTP

UDP在传送数据之前不需要建立连接，目的主机收到UDP报文后，不需要给出确认。UDP不提供可靠交付，一般用于即时通信，如语音、视频、直播等。RIP(路由选择协议)，DNS

### 5、TCP粘包现象原因和解决方法 

TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。原因可能是发送方也可能是接收方造成的。

发送方原因：TCP默认使用Nagle算法，将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。

接收方原因：TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。

 

如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了。处理方法：发送方关闭Nagle算法。

接收方：接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。应用层循环读取所有的数据，根据报文的长度判断每个包开始和结束的位置。

### 4、TCP可靠传输的保证，拥塞控制目和过程 

TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的。而UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。



滑动窗口：

TCP通过滑动窗口的概念来进行流量控制，抑制发送端发送数据的速率，以便接收端来得及接收。

窗口：对应一段发送者可以发送的字节序列。这个序列是可以改变的。接收端发给发送端自己的接受能力。然后发送端根据已确认接受的序列号和接受能力滑动窗口，一下子全部发送，等待接收端确认。

拥塞控制：

和流量控制的区别：

拥塞控制是防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载，是一个全局性的过程。

流量控制是点对点通信量的控制,主要就是抑制发送端发送数据的速率，以便接收端来得及接收。

(设置拥塞控制窗口cwnd, 在发送数据时，将拥塞窗口的大小与接收端ack的窗口大小做比较，取较小者作为发送数据量的上限。)

慢开始: 设置拥塞控制窗口cwnd = 1，没收到一个ACK,cwnd++;每过1RTT,cwnd = cwnd * 2;呈指数增长。

拥塞避免：当拥塞窗口 cwnd 达到一个阈值时（cwnd >= ssthresh），窗口大小不再呈指数上升，而是以线性上升，避免增长过快导致网络拥塞。每当过了一个RTT，cwnd = cwnd + 1；

无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(没有收到确认ACK);拥塞窗口设置为1，阈值为拥塞时发送窗口的一半，执行慢开始算法。

快重传：当发送方连续收到三个重复确认时，就立即重传对方尚未收到的报文段。并执行快恢复算法

快恢复：将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。

### 8、TCP、UDP、IP、以太网报文格式以及重要字段，报文从一端到另一端传递的过程。

数据报文的结构：应用程序+TCP/UDP报文头部+IP报文头部(到这是以太网帧，46-1500)+以太网头部；

TCP报文头部结构：（前20字节固定）16为源端口号+16位目的端口号+32位序号+32位确认号+4位头部长度（单位4字节）+6位保留+6个关键字（SYN,ACK，FIN）+16位窗口大小（指接收窗口）+16位校验和+16位紧急指针+最多40字节的选项；

UDP报文头部结构首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。：

IP报文头部结构：

4位版本+4位首部长度（单位4字节）+8位服务类型+16位总长度（字节）

16位标识（分组）+3位标志（是否分组）+13为片内偏移

8位TTL+8位上层协议+16位首部检验和

32位源IP地址

32位目的IP地址

 

以太网头部：

6字节目的地址+6字节源地址+2字节类型。这个地址指MAC地址。



点对点和端对端的区别：

点到点通信是针对数据链路层或网络层来说的，因为数据链路层只负责直接相连的两个节点之间的通信，一个节点的数据链路层接受ip层数据并封装之后，就把数据帧从链路上发送到与其相邻的下一个节点。 点对点是基于MAC地址和或者IP地址，是指一个设备发数据给与该这边直接连接的其他设备，这台设备又在合适的时候将数据传递给与它相连的下一个设备，通过一台一台直接相连的设备把数据传递到接收端。

 

端到端通信是针对传输层来说的，传输层为网络中的主机提供端到端的通信。因为无论tcp还是udp协议，都要负责把上层交付的数据从发送端传输到接收端，不论其中间跨越多少节点。只不过tcp比较可靠而udp不可靠而已。所以称之为端到端，也就是从发送端到接收端。它是一个网络连接，指的是在数据传输之前，在发送端与接收端之间（忽略中间有多少设备）为数据的传输建立一条链路，链路建立以后，发送端就可以发送数据。



IP数据报传输的过程：(无论怎么传，IP源和目的地址不变，但MAC目的和源地址会变)

IP数据报需从主机A上传送到主机B上，主机A首先查找路由表;

if(目的主机是与自己在同一个网段内)

​    主机A查询自己的ARP表;如果存在目的IP地址到MAC的映射，将MAC地址作为目的MAC地址封装成帧，发  给主机B.如果没有，发送ARP请求广播给网段内的所有主机，来查询该目的IP地址的MAC地址

else if(发现了能与目的网络号相匹配的表目)

​    则把报文发给该路由表目指定的下一站的路由器或直接连接的网络接口;

​    报文发送到下一站时，数据帧的目的MAC地址是下一个站路由器或者网络接口的MAC地址，而IP头部的目的IP 地址是主机B的IP地址;

else

​    寻找标为“默认”的表目，把报文发送给该表目指定的下一站路由器;

### 	6、TCP三次握手过程以及每次握手后的状态改变，为什么三次？为什么两次不行？如果你的答案是防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源，但这个答案被否定了，你还能给出什么答案？ 

**TCP****三次握手：**

​    1、客户端向服务器发送TCP连接请求数据包，其中同步标志为SYN=1,ACK=0,初始序列号为x;( syn_sent,等待回复)

​    2、服务器收到请求后，发回连接确认包。SYN=1，ACK=1,ack=x+1,初始序列号为y;( syn_rcvd,收到请求，等待回复)

​    3、客户端收到确认报文后，还需发送确认数据包。ACK=1,ack=y+1,序列号为x+1;( ESTABLISHED,完成三次握手)

​                               

三次握手是为了建立可靠的通信信道，双方都确认自己和对方的发送和接受都是正常的。SYN=1表示这是个连接请求或连接接受报文，不携带数据。不能变成两次，已失效的连接请求报文段突然又传送到了服务端，服务端误以为是正常的连接请求，直接发送连接确认报文，导致TCP建立，浪费资源，因而产生错误。

 

 

1、TCP握手协议

 

第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

在上述过程中，还有一些重要的概念：

未连接队列：在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。

 

2、SYN攻击原理

 

SYN攻击属于DOS攻击的一种，它利用TCP协议缺陷，通过发送大量的半连接请求，耗费CPU和内存资源。

 

配合IP欺骗，SYN攻击能达到很好的效果，通常，客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。

 

第一种是缩短SYN Timeout时间，由于SYN Flood攻击的效果取决于服务器上保持的SYN半连接数，这个值=SYN攻击的频度 x SYN Timeout，所以通过缩短从接收到SYN报文到确定这个报文无效并丢弃改连接的时间，例如设置为20秒以下（过低的SYN Timeout设置可能会影响客户的正常访问），可以成倍的降低服务器的负荷。

 

第二种方法是设置SYN Cookie，就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被一概丢弃。

 

可是上述的两种方法只能对付比较原始的SYN Flood攻击，缩短SYN Timeout时间仅在对方攻击频度不高的情况下生效，SYN Cookie更依赖于对方使用真实的IP地址，如果攻击者以数万/秒的速度发送SYN报文，同时利用SOCK_RAW随机改写IP报文中的源地址，以上的方法将毫无用武之地。

 

net.ipv4.tcp_syncookies = 1

net.ipv4.tcp_max_syn_backlog = 8192

net.ipv4.tcp_synack_retries = 2

分别为启用SYN Cookie、设置SYN最大队列长度以及设置SYN+ACK最大重试次数。

 

 

SYN Cookie的作用是缓解服务器资源压力。启用之前，服务器在接到SYN数据包后，立即分配存储空间，并随机化一个数字作为SYN号发送SYN+ACK数据包。然后保存连接的状态信息等待客户端确认。启用SYN Cookie之后，服务器不再分配存储空间，而且通过基于时间种子的随机数算法设置一个SYN号，替代完全随机的SYN号。发送完SYN+ACK确认报文之后，清空资源不保存任何状态信息。直到服务器接到客户端的最终ACK包，通过Cookie检验算法鉴定是否与发出去的SYN+ACK报文序列号匹配，匹配则通过完成握手，失败则丢弃。

net.ipv4.tcp_synack_retries是降低服务器SYN+ACK报文重试次数，尽快释放等待资源。

tcp_max_syn_backlog则是使用服务器的内存资源，换取更大的等待队列长度，让攻击数据包不至于占满所有连接而导致正常用户无法完成握手。

 

 

SYN Flood是当前最流行的DoS（拒绝服务攻击）与DDoS（分布式拒绝服务攻击）的方式之一，这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，从而使得被攻击方资源耗尽（CPU满负荷或内存不足）的攻击方式。



### 7、TCP四次挥手过程以及状态改变，为什么四次？CLOSE-WAIT和TIME-WAIT存在的意义？如何查看TIME-WAIT状态的链接数量？为什么会TIME-WAIT过多？解决方法是怎样的？ 

TCP四次挥手：

​                                   

​    由于TCP连接是全双工的，因此每个方向都必须单独关闭。当一方数据发送任务完成之后，可以发送FIN来终止这个方向的连接。而另一方可以继续发送数据。

​    1、客户端发送请求释放连接报文，FIN=1,seq=u;客户端进入FIN-WAIT-1状态；

​    2、服务器收到请求，发送确认报文。ACK=1,seq=v,ack=u+1;服务器进入CLOSE-WAIT状态。客户端收到后进入终止等待2FIN-WAIT-2;

​    3、服务器发送完数据之后，向客户端发送请求释放连接报文，FIN=1,ACK=1,seq=w,ack=u+1;进入LAST-ACK状态

​    4、客户端收到请求后，发送确认报文，ACK=1,seq=u+1,ack=w+1。客户端进入TIME-WAIT状态，等待2MSL后进如CLOSED状态，服务器收到确认后进如CLOSED状态。

为什么关闭的时候是四次挥手，因为TCP连接时全双工的，每个方向都要发送关闭请求，而另一方向都要确认。

TIME_WAIT状态为什么要等待2MSL：因为第四次的确认报文可能丢失，这个状态是用来重发可能丢失的ACK报文。

为什么会有CLOSE_WAIT,因为服务器可能有数据未发送完毕，这段时间是继续发送数据的。

如果建立连接之后出现故障：TCP有个保活计时器，通常设置为2小时，两小时内没有收到客户端发送的数据，服务器发送探测报文，每75s发送一次，10次之后探测报文没有反应，认为出现故障，关闭连接。

TIME_WAIT存在的两个理由：

1 可靠的实现TCP全双工连接的终止

2 允许老的重复的分节在网络上的消逝（TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个TCP连接的时候，来自连接先前化身的重复分组已经在网络中消逝。）

 

 

 

netstat -an |grep "TIME_WAIT" 查看处于Time_wait状态的连接详细情况

netstat -ae|grep "TIME_WAIT" |wc -l 查看处于Time_wait状态的连接个数

 

在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。

 

正常的TCP客户端连接在关闭后，会进入一个TIME_WAIT的状态，持续的时间一般在1~4分钟，短时间内（例如1s内）进行大量的短连接，则可能出现这样一种情况：客户端所在的操作系统的socket端口和句柄被用尽，系统无法再发起新的连接！

 

解决方法：

net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；

net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；

net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。

net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间

简单来说，就是打开系统的TIMEWAIT重用和快速回收。



### 9、浏览器输入URL并回车的过程以及相关协议，DNS查询过程。 

​    1、根据域名查询域名的IP地址，DNS解析。2、TCP连接3、发送HTTP请求4、服务器处理请求并返回HTTP报文5、浏览器解析渲染页面6、连接结束。

​    使用的协议：DNS(获取域名的IP的地址);TCP(与服务器建立TCP连接)；IP(建立TCP协议时，需发送数据，在网络层用到IP协议)；OPSF(IP数据包在路由之间传送，路由选择使用OPSF协议)；ARP(路由器与服务器通信时，将IP地址转化为MAC地址，使用ARP协议)HTTP(TCP建立之后，使用HTTP协议访问网页)；

​    DNS寻址：先查找浏览器缓存，如果没命中，查询系统缓存，即hosts文件。如果没命中，查询路由器缓存。如果没命中，请求本地域名服务器解析域名，没有命中就进入根服务器进行查询。没有命中就返回顶级域名服务器IP给本地DNS服务器。本地DNS服务器请求顶级域名服务器解析，没有命中就返回主域名服务器给本地DNS服务器。本地DNS服务器请求主域名服务器解析域名，将结果返回给本地域名服务器。本地域名服务器缓存结果并反馈给客户端。



### 10、HTTP1.0、1.1、2之间的区别 

​    HTTP1.1与1.0之间的区别:1、HTTP1.1默认开启长连接，在一个TCP连接上可以传送多个HTTP请求和响应。而1.0不支持长连接。客户端和服务器每进行一次HTTP操作，就建立一次连接。2、缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。3、Host头处理：1.0请求的url并没有传递主机名(服务器与IP地址绑定)，1.1请求和响应都支持Host头域(虚拟主机共享IP地址)4、1.1新增24个错误状态响应码。409：请求的资源和资源的当前状态冲突，410：服务器资源永久性删除。5、带宽优化以及网络连接的使用：1.1允许只请求资源的某个部分.

HTTP2.0和HTTP1.X相比的新特性

​    1、新的二进制格式：1.x的解析是基于文本的，而2.0的协议解析是采用二进制格式。2、多路复用，即连接共享，即每一个request都是是用作连接共享机制的；。一个request对应一个id，这样一个连接上可以有多个request。3、header压缩。4、服务端推送。

### 11、HTTP与HTTPS之间的区别，HTTPS链接建立的过程，了解对称加密算法和非对称加密算法不？

1、HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。

​    2、HTTP协议运行在TCP之上，传输的内容都是明文。HTTPS运行在SSL/TLS(运行在TCP之上)之上，内容加密。

​    3、连接端口不一样，http是80，https是443.

​    4、http连接简单，没有状态，https是ssl加密的传输，身份认证的网络协议，更安全。

HTTPS在传统的HTTP和TCP之间加了一层用于加密解密的SSL/TLS层；采用 对称加密和非对称加密结合的方式来保护浏览器和服务端之间的通信安全。对称加密：加密和解密都是同一个密钥。非对称加密：密钥成对出现，分为公钥和私钥，公钥和私钥之间不能互相推导，公钥加密需要私钥解密，私钥加密需要公钥解密。

 

浏览器使用Https的URL访问服务器，建立SSL链接；

![](C:\Users\11709\Desktop\SSP\6.计算机网络\image\HTTPS连接建立过程.png)

1、发送非对称加密的公钥A给浏览器

2、客户端(SSL/TLS)解析证书（无效会弹出警告）

3、生成随机值(这个相当于传送数据的密钥)，作为对称加密的密钥B。

4、浏览器使用服务器返回的公钥A，对自己生成的对称加密密钥B进行加密，得到密钥C。

5、浏览器将密钥C发送给服务器

6、务器使用自己的私钥D对接受的密钥C进行解密，得到对称加密密钥B。

7、将信息和密钥B混合在一起进行对称加密

8、将加密的内容发送给客户端

9、客户端用密钥B解密信息

 

​                               

加密过程使用了对称加密和非对称加密。

 

对称加密: 客户端和服务端采用相同的密钥经行加密

  encrypt(明文，秘钥) = 密文

  decrypt(密文，秘钥) = 明文

非对称加密：客户端通过公钥加密。服务端通过私钥解密

  encrypt(明文，公钥) = 密文

decrypt(密文，私钥) = 明文

 

验证证书：

客户端获取到了站点证书，拿到了站点的公钥

客户端找到其站点证书颁发者的信息

站点证书的颁发者验证服务端站点是否可信

 

   非对称加密算法：RSA，DSA/DSS 

   对称加密算法：AES，RC4，3DES 

   HASH算法：MD5，SHA1，SHA256

![](C:\Users\11709\Desktop\SSP\6.计算机网络\image\HTTPS链接.png)

 

### 12、HTTP请求有哪些，多说点。Post和get区别

get:请求特定资源2、post:向指定资源提交数据进行处理请求。Put:向指定资源上传最新内容。Delete:请求删除资源。

​    Get是从指定资源请求数据，而Post是向指定资源提交要被处理的数据。Get请求刷新无害，而post刷新，数据会被重复提交。Get请求的数据会附加到URL中，多个参数用&连接，URL编码采用ASCII编码。而POST请求会把请求的数据放到body中。因此get请求的数据会暴露在地址栏中，而post不会。又浏览器和服务器对url的长度有限制，所以get传输数据的大小受到url的限制。Get请求的资源会被浏览器缓存。post比get慢，因为post在发送数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据。而get请求直接发送请求头和数据。

### 13、HTTP常见响应状态码，从1xx到5xx都要说。如304,301,302，504，

​    304：客户端请求一个有缓存的资源，服务器返回304告诉客户端，自上次请求后，资源并没有更新，原本的缓存可以继续使用。

1xx：指示信息--表示请求已接收，继续处理 

   100 --客户端必须继续发出请求 101-客户端要求服务器转换HTTP协议版本。

2xx：成功--表示请求已被成功接收、理解、接受

​    200—OK  204--请求收到，但返回信息为空 206--服务器已经完成了部分用户的GET请求

3xx：重定向--信息不完整需要进一步补充

​    300 --- 请求资源在多处可得到。301—永久重定向，隐式重定向。302 临时重定向，显示重定向。

​    304—请求的资源没有改变，可以使用缓存。

4xx：客户端错误--请求有语法错误或请求无法实现

​    401---未授权 403—禁止访问。 404 –找不到。409：对当前资源状态，请求不能完成

5xx：服务器端错误--服务器未能实现合法的请求

​    500内部服务器错误，501未实现， 502网关错误，503服务不可用，504 网关超时。



### 	14、重定向和转发区别 

转发和重定向的区别:

​    转发（forward）是服务器行为，重定向是客户端行为。

​    转发是服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。效率高，可用于用户登录之后将角色转发到相应的模块。

​    重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器到新的网址重新请求资源。地址栏url会发生改变，而且不能共享数据。效率低，可用于用户注销之后，跳转到其他网站。



### 15、cookie和session区别。

Session和Cookie的区别：

​    Cookie技术是客户端的解决方案，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端， 然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。

​    客户端发送一个http请求到服务器端

​    服务器端发送一个http响应到客户端，其中包含Set-Cookie头部

​    客户端发送一个http请求到服务器端，其中包含Cookie头部

​    服务器端发送一个http响应到客户端

Cookie的不可跨域名性

​    Session保存在服务器上。 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。 客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。服务器一般把Session放在内存中。 每个用户都会有一个独立的Session。Session在用户第一次访问服务器的时候自动创建, 创建Session的同时，服务器会为该Session生成唯一的session id,session id会以cookie的方式发送个客户端。客户端下次访问时，带上这个session id，就可以跟踪会话了。如果浏览器不支持cookie，可以用url重写的方式，将sessionId写入url传给服务器。



## Java基础

### 1、面向对象特性介绍、与C++区别 

### 	2、多态实现原理 

多态的实现原理

​    多态是指一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

​    Java多态允许父类引用变量指向子类对象，引用变量发出的方法调用到底是哪个对象实现的方法，必须在由程序运行期间才能决定。java中的方法调用有静态绑定和动态绑定之分，静态绑定指的是我们在编译期就已经确定了会执行那个方法的字节码，而动态绑定只有在运行时才能知晓。Java中的静态方法、私有方法以及final修饰的方法的调用，都属于静态绑定，对于重载的实例方法的调用，也是采用静态绑定。方法调用动作会被编译成静态调用指令，该指令对应常量池中方法的符号引用。

​    Java 对于方法调用动态绑定的实现主要依赖于**方法表**，但通过**类引用调用和接口引用调用**的实现则有所不同。总体而言，当某个方法被调用时，JVM 首先要查找相应的**常量池**，得到**方法的符号引用**，并查找调用类的方法表以确定该**方法的直接引用**，最后才真正调用该方法。以下分别对该过程中涉及到的相关部分做详细介绍。

​    动态绑定：JVM有个方法表：记录当前类以及所有父类的可见方法字节码在内存中的直接地址

### 3、抽象类和接口区别，以及各自的使用场景 

抽象：就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。抽象包括两个方面：一个是数据抽象，一个是过程抽象。数据抽象也就是对象的属性。过程抽象是对象的行为特征。

​    封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行封装隐藏。封装分为属性的封装和方法的封装。核心思想就是“隐藏细节”、“数据安全”：将对象不需要让外界访问的成员变量和方法私有化，只提供符合开发者意愿的公有方法来访问这些数据和逻辑，保证了数据的安全和程序的稳定。好处：良好的封装能减少耦合，对成员变量更精确的控制。

​    继承：子类可以继承父类的非私有方法和属性(默认属性和方法也不行)，达到复用代码的效果。Java是单继承，一个类只能继承一个父类。

​    多态: 不同类的对象对同一消息作出不同的响应叫做多态。同一消息可以根据发送对象的不同而采用多种不同的行为方式。可以用于消除类型之间的耦合关系，Spring 的核心就是多态和面向接口编程。多态的分类，编译时多态，方法的重载，运行时多态，方法的覆盖。多态存在的条件：存在继承关系，子类重写父类的方法，父类引用指向子类。

​    Java 里对象方法的调用是依靠类信息里的方法表实现的。

 

重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。

重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。

 

抽象类和接口：

抽象类可以有构造函数，接口不可以有构造函数 

抽象类中可以有普通成员变量，接口中没有普通成员变量，只能有常量
 抽象类中的方法可以被static修饰，接口中的方法不可以被static修饰 **---> jdk 1.8** **可以接口可以有****static****修饰的方法**
 抽象类中可以有普通方法和抽象方法，接口中的方法全是抽象方法 **---> jdk 1.8** **接口中的方法还有****default****和****static****修饰的方法**

一个类只能继承一个抽象类，接口可以被多实现，即一个类只能继承一个类，可以实现多个接口 

​    何时使用

接口主要用于模块与模块之间的调用。主要用接口来实现多继承，因为java不支持类的多继承，只能用接口 

抽象类主要用于当做基础类使用，即基类。如果想拥有一些方法，并且这些方法有默认实现，那么使用抽象类

​    1.如果要实现的类和该抽象类是同一类事物，则用继承抽象类的方法；不是同一类事物，就用接口；2.要设计较小的功能模块，用接口，要设计较大的功能单元，用抽象类；3.如果大部分方法都不确定，用接口抽象所有方法；如果只有少部分方法不确定，另有部分方法是确定的，用抽象类，实现部分确定的方法，抽象部分不确定的方法。

 

语法层次

抽象类和接口分别给出了不同的语法定义。

抽象类中可以有普通方法和抽象方法public abstract，接口中的方法全是抽象方法，抽象类中可以有普通成员变量，接口

中没有普通成员变量，只能有常量public static final。

一个重要的原则：当一个类实现了一个接口，要求该类把这个接口的所有方法全部实现

接口还可以继承多个接口。

 

设计层次

抽象层次不同，抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。

 

跨域不同

抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在"is-a"

关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的，仅仅是实现了接口定义的契约而已，"like-a"的关系。



###	4、泛型以及泛型擦除。List<A>类型的list,可以加入无继承关系的B类型对象吗？如何加入？ 

泛型

泛型，即“参数化类型”。

创建集合时就指定集合元素的类型，该集合只能保存其指定类型的元素，避免使用强制类型转换。

 

Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程即类型擦除。泛型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。

类型擦除的主要过程如下：

1）将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。

2）移除所有的类型参数。



### 5、Java异常体系 

异常也是一种对象，java当中定义了许多异常类，并且定义了基类java.lang.Throwable作为所有异常的超类。Java语言设计者将异常划分为两类：Error和Exception。

1、Error（错误）：是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时JVM出现问题。通常有Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。StackOverflowError，OutOfMemoryError。

2、Exception（异常）：程序本身可以捕获并且可以处理的异常。

Exception这种异常又分为两类：运行时异常和编译异常。

​    1、运行时异常(免检异常)：RuntimeException类极其子类表示JVM在运行期间可能出现的错误。比如说试图使用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。ArithmeticException，ClassCastException，NumberFormatException，IllegalArgumentException。

​    2、编译异常(受检异常)：Exception中除RuntimeException极其子类之外的异常。如果程序中出现此类异常，比如说IOException，必须对该异常进行处理，否则编译不通过。在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。ClassNotFoundException，InterruptedException。

 



 

 





###	

### 6、反射原理以及使用场景 

定义：在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法，这种动态获取信息以及动态调用对象方法的功能成为Java反射机制。

​    提供的功能：在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；

​    原理：获取类的Class对象，然后反向获取类或对象的各种信息。（class对象和.class文件的构造？？？）

​    获取class对象的三种方法：Class.forName("全类名")；类名.class；对象.getClass()；

​    然后根据class对象获取类的各种信息  : getMethods()获取所有public方法，getConstructors()获取构造方法，获取getDeclaredFields()获取所有的属性。class.newInstance() ,并强转类型，然后就可以操作对象了。对私有方法和属性，可以setAccessible(true)，然后进行操作。所以反射是能够改变单例模式的，只需要获取私有的构造方法，然后setAccessible(true),然后通过构造方法创建对象就行。但并不破坏封装。封装的含义和单例的含义不一样，封装是将一组程序封装起来，对外提供接口，让外部调用人员不必在意里面的实现环节，直接调用即可。而外部人员及时通过反射获取到了里面的一些私有，仍然是不能窥探其实现逻辑的，单纯的调用其私有方法， 没有任何的意义。

​    反射的应用场景：

​    我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性。



### 7、ThreadLocal原理，如何使用？ 

ThreadLoacl

​    ThreadLocal类用来提供线程内部的局部变量，这种变量在多线程环境下访问时能保证各个线程里的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static 类型，用于关联线程。static的ThreadLocal变量是一个与线程相关的静态变量，即一个线程内，static变量是被各个实例共同引用的，但是不同线程内，static变量是隔开的。

​    使用方法：一个class中定义了一个ThreadLocal变量。通过重写方法initialValue()初始化值。然后设置get()方法得到threadLocal.get();通过设置set()方法设置threadLoca.set(threadLocal.get()+10);然后一个线程任务对这个类的变量进行修改或者查找时，每个线程的变量使用的都是线程局部变量，互不影响。

​    

​    每个线程对象：Thread t = Thread.currentThread();每个线程对象都有自己的ThreadLocalMap的变量，Map变量，key值为ThreadLocal，value为值。所以每个线程都有自己的一个ThreadLocal变量，且各自的值独立。

Get的时候，先获取线程的ThreadLocalMap对象，如果存在的话，就获取他的值。

Set的时候，先获取线程的ThreadLocalMap对象，如果存在，就更新。不存在，就新建Map,key为ThreadLocal,值为value;

​    总的来说，每个线程对象，都有自己的ThreadLocalMap变量，这个map变量，key就是自己维持的ThreadLocal对象,值为ThreadLocal的值。

​    因为线程必然要访问threadLocal变量，然后调用threadLocal.get()方法，这个方法的实现就是：先获取当前线程，然后获取当前线程的ThreadLocalMap对象，map对象的key就是维持的ThreadLocal对象，value就是变量的值。

public T get() {

​     Thread t = Thread.currentThread();//获取当前线程

​     ThreadLocalMap map = getMap(t);//获取当前线程的ThreadLocalMap对象

​    if (map != null) {

​      ThreadLocalMap.Entry e = map.getEntry(this); //当前线程Map对象，是否含有此TreadLocal对象实例最为key,如果有，取值。

​      if (e != null) {

​        @SuppressWarnings("unchecked")

​        T result = (T)e.value;

​        return result;

​      }

​    }

​    return setInitialValue();

  }



### 8、内存泄漏的场景

单纯将ThreadLocal置为null，ThreadLoca只有一个指向Map的key的虚引用，是可以回收的；但是，从CurrentThread-----Thread------ThreadLocalMap----Entry的value是存在强引用的。这时，如果线程对象不被回收，例如线程池，就可能出现内存泄露了。所以我们Threadlocal的时候，要用remove()方法。

​    **内存泄露的场景：**

   **使用静态的集合类**：静态的集合类的生命周期和应用程序的生命周期一样长；

​    **单例模式可能会造成内存泄露**：实例对象的生命周期和应用程序的生命周期一样长，如果单例对象中拥有另一个对象的引用的话，这个被引用的对象就不能被及时回收；

​    **数据库、网络、输入输出流，这些资源没有显示的关闭**

​    **使用非静态内部类：****非静态内部类对象的构建依赖于其外部类**，内部类对象会持有外部类对象的this引用，即时外部类对象不再被使用了，其占用的内存可能不会被GC回收，因为内部类的生命周期可能比外部类的生命周期要长，从而造成外部类对象不能被及时回收。解决办法是尽量使用静态内部类，

​    变量不合理的作用域：能声明局部变量，就不要整成成员变量。



### 9、static关键字和final关键字使用情况，一个类不能被继承，除了final关键字之外，还有什么方法（从构造函数考虑）？

 

非静态内部类：

  \1. 内部类对象的创建依赖于外部类对象；

  \2. 内部类对象持有指向外部类对象的引用。(静态内部类则不持有)；

 

Java和c++的区别？

static关键字和final关键字

static关键字：static的主要作用在于创建独立于具体对象的域变量或者方法。类变量随着类的加载而存在于方法区中。实例变量随着对象的建立而存在于堆内存中。类变量生命周期最长，随着类的消失而消失。实例变量生命周期随着对象的消失而消失。

​    static修饰方法：静态方法。不依赖于对象就可以访问，可以直接类名.静态方法访问。静态方法不可以访问对象的非静态方法和非静态变量。

​    static变量：静态变量被所有的对象所共享，在内存中只有一个副本，存在方法区中，当且仅当在类初次加载时会被初始化。

​    static静态代码块：在类被初次加载时执行，且执行一次，通常将只需要进行一次的初始化操作都放在static代码块中进行。

​    static静态内部类:内部类：定义在类内部的类叫做内部类，内部类持有外部类的引用，所以能够访问外部类的所有变量和方法，内部类一般只为外部类使用，且内部类能够独立的继承接口。外部类对象通过‘外部类名.this.xxx’的形式访问内部类的属性与方法。static修饰之后就叫做静态内部类，或嵌套类 [1]要创建静态内部类的对象，并不需要其外部类的对象；也没有持有外部类的引用。 [2]不能够从静态内部类的对象中访问外部类的非静态成员。

​    每个类会产生一个.class文件，文件名即为类名。同样，内部类也会产生这么一个.class文件。内部类也会有class文件，文件名为外部类$内部类名称。

​    static静态导包：import static myClass.*;导入类的所有静态  方法或者调用特定静态方法。使用时直接使用方法名称就可以。

​    final:

​    final修饰变量表示常量，只能被赋值一次，赋值后值不再改变.这里的不可变，是指引用不可变，如果修饰list,随便增删。如果修饰的类的成员变量，必须显示初始化，要么直接赋值，要么构造方法中初始化。否则就会报编译错误

​    final修饰方法，表示方法不可被重写。final方法编译的时候静态绑定，所以比非final方法快。private方法其实也是final的。final方法在编译阶段绑定，称为静态绑定(static binding)。

​    final修饰类，表示不可被继承。final类中的所有方法都是final方法。

​    不用final还可以用什么办法使得这个类不被继承、

​    将我们的类的构造器声明为private类型的。然后继承的子类，必须得调用父类的构造方法， 因为他是私有的构造函数，不能调用，出错。

 

​    重排序情况：编译器优化的重排序、指令并行重排序，内存系统重排序。

​    在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。

​    \1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。

​    \2. 两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。

​    规则八种：程序次序规则（在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！）、锁定规则、volatile变量规则、传递规则、线程启动规则、线程中断规则、线程终结规则、对象终结规则。



### 10、序列化和反序列化。反序列化失败的场景。

序列化和反序列化：

​    java序列化是指把java对象转换为字节序列的过程，而java反序列化是指把字节序列恢复为java对象的过程。

​    序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。反序列化：客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。

​    （利用序列化实现远程通信，可以在网络上传送对象的字节序列。在进程间传递对象，永久性保存对象）

----JDK类库中序列化的步骤 ：只有实现了Serializable或Externalizable接口的对象才能被序列化，否则抛出异常！

如果类a仅仅实现了Serializable接口，则

ObjectOutputStream采用默认的序列化方式，对a对象的非transient实例变量进行序列化

ObjectInputStream采用默认的反序列化方式，对a对象的非transient实例变量进行反序列化

 

反序列化失败: 没有添加 serialVersionUID 可能会导致反序列化失败.

继承了一个已经实现序列化接口的父类,并且与父类有重复的属性,在反序列化的时候就会导致重复的属性数据丢失.

 

--1--创建一个对象输出流，它可以包装一个奇特类型的目标输出流，如文件输出流：

objectOutputStream oos=new objectOutputStream(new FileOutStream(c:\\object.out));

--2--通过对象输出流writeObject()方法写对象：

oos.writeObject(new a("xiaoxiao","145263","female"));

----JDK类库中反序列化的步骤

--1--创建一个对象输入流，它可以包装一个其他类型输入流，如文件输入流：

objectInputStream ois=new ObjectInputStream(new FileInputStream("object.out"));

--2--通过对象输出流的readObject()方法读取对象：

a aa=(a)ois.readObject();

--3--为了正确读数据，完成反序列化，必须保证向对象输出流写对象的顺序与从对象输入流中读对象的顺序一致



### 11、ArrayList和LinkedList的区别和底层实现？如何实现线程安全？ 

ArrayList

​    底层实现是Object数组（transient Object[] elementData）;

​    默认长度是10, 扩容是变成1.5倍：int newCapacity = oldCapacity + (oldCapacity >> 1);

​    扩容是创建新的数组，elementData = Arrays.copyOf(elementData, newCapacity)

​    增减删除，会造成数组元素的移动，使用System.arraycopy();

​    支持随机访问;    

LinkedList

​    LinkedList 实际上是通过双向链表去实现的,内部类Node(val,next,pre)是链表的节点;

  它也可以被当作堆栈、队列或双端队列进行操作。

  不支持随机访问，但删除、插入元素时间不受元素位置影响，近似O(1),而ArryList是O(n);

Vector

  底层实现也是Object数组，线程安全,支持随机访问

  默认长度是10， capacityIncrement增长系数，如果设置，每次扩展都是增加这个数，否则扩容为2倍。

  

​    (01) 对于需要快速插入，删除元素，应该使用LinkedList。

  (02) 对于需要快速随机访问元素，应该使用ArrayList。

  (03) 对于“单线程环境” 或者 “多线程环境，但List仅仅只会被单个线程操作”，此时应该使用非同步的类(如ArrayList)。

对于“多线程环境，且List可能同时被多个线程操作”，此时，应该使用同步的类(如Vector)。

Collections.synchronizedList(new ArrayList<Map<String,Object>>());



### 12、List遍历时如何删除元素？fail—fast是什么？fail—safe是什么？ 

快速失败（fail—fast）

​    在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception;

​    迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。

 

 当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。这个机制是防止多线程并发访问list可能带来错误，所以抛出异常提醒一下。

 Fail-Fast : List维护一个modCount变量，add、remove、clear等涉及了改变list元素的个数的方法都会导致modCount的改变。如果判断出modCount != expectedModCount, 抛出ConcurrentModificationException 异常，从而产生fail-fast机制。

 并发安全的解决方案：

1、Collections.synchronizedList。或者每个访问操作sychronized加锁。

2 CopyOnWriteArrayList来替换ArrayList。推荐使用该方案。

CopyOnWriterArrayList所代表的核心概念就是：任何对array在结构上有所改变的操作（add、remove、clear等），CopyOnWriterArrayList都会copy现有的数据，再在copy的数据上修改，这样就不会影响COWIterator中的数据了，修改完成之后改变原有数据的引用即可。同时这样造成的代价就是产生大量的对象，同时数组的copy也是相当有损耗的。

 

安全失败（fail—safe）

​    采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。

​    java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。

fail-safe机制有两个问题

（1）需要复制集合，产生大量的无效对象，开销大

（2）无法保证读取的数据是目前原始数据结构中的数据。



### 13、详细介绍HashMap。角度：数据结构+扩容情况+put查找的详细过程+哈希函数+容量为什么始终都是2^N+JDK1.7与JDK1.8的区别。

### 14、HashMap如何实现线程安全？ConcurrentHashMap的底层实现？JDK1.7与JDK1.8的区别 

HashMap

​    HashMap底层是数组和链表结合在一起，也就是链表散列； 怎么更通顺的说出来？？？

​    hashMap底层是数组+链表+红黑树。首先是table数组，每个数组存放的是链表，链表的每一个节点都是<Key,Value>型的Node节点。

  JDK1.8之后，当链表长度超过阈值，默认为8时，为加快检索速度，将链表转化成红黑树。

默认加载因子是 0.75, 默认的初始容量是16，容量就是数组长度，如果size大于容量*加载因子，就进行rehash;

容量扩容成两倍;

  如果初始化时指定初始容量，要向上取到2的N次方。因为对key的hashCode进行扰动函数处理之后，是根据（n-1）& hash判断元素在数组中的位置的。

  使用(n-1) & hash是为了效率考虑，而只有数组长度为2的N次方，才能使n-1 & hash起到取余操作的作用。

  hash(key) ----> return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);-----key的扰动函数;减少碰撞;

  (n-1) & hash---判断元素在数组中的位置。数组中存放的是Node<k,v>节点。

  查询get(key)时，先判断在数组中的位置，key的hashCode无符号右移16，再异或，取余;然后在链表中搜索;

put,也是先查询在数组中的问题，然后判断链表中，key是否存在，存在就更新， 不存在头插法，插入链表;

 

​    红黑树的平均查找长度是log(n)，长度为8，查找长度为log(8)=3，链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，这才有转换成树的必要；链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。中间有个差值7可以防止链表和树之间频繁的转换。

​    而且理想情况下，在随机哈希代码下，桶中的节点频率遵循泊松分布，文中给出了桶长度k的频率表。
 由频率表可以看出，桶的长度超过8的概率非常非常小（千万分之一）。所以作者应该是根据概率统计而选择了8作为阀值。

​    TreeMap是基于红黑树实现的一个保证有序性的Map 基于红黑树，所以TreeMap的时间复杂度是O(log n)，

 

HashMap冲突解决方法：开发地址法，当冲突发生时，使用某种探查(亦称探测)技术（线性探测，随机探测，不同的关键字使用不同的探测距离）在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者找到空。

2、拉链法

 

多线程PUT可能发生的问题：

1、当多个线程同时执行addEntry(hash,key ,value,i)时，如果产生哈希碰撞，导致两个线程得到同样的bucketIndex去存储，就可能会发生元素覆盖丢失的情况

2、JDK1.7以前。在向HashMap put元素时，会检查HashMap的容量是否足够，如果不足，则会新建一个比原来容量大两倍的Hash表，然后把数组从老的Hash表中迁移到新的Hash表中，迁移的过程就是一个rehash()的过程，多个线程同时操作就有可能会形成循环链表。

 

扩容方式：遍历数组，然后遍历数组链表，从链表头到尾，保留next = e.next;先计算出节点在新hashmp的数组位置i，然后用头插法将节点插入到新数组的头结点（e.next = new B）。e = next; do while(e != null)之后的一样。

单线程是没问题的，如果是多线程的话，那么可能 next = e.next；被干扰的话 next = B;造成死循环。影响扩容。

HashMap扩容导致死循环的主要原因在于扩容后链表中的节点在新的hash桶使用头插法插入。

JDK1.8扩容时，将原节点用尾插法将节点插入到新的hashmap中。

当然，他们都不是线程安全的，线程安全还是得用ConcurrentHashMap;

红黑树的特性

  （1）每个节点或者是黑色，或者是红色。

  （2）根节点是黑色。

  （3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]

  （4）如果一个节点是红色的，则它的子节点必须是黑色的。

  （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。）

   它的时间复杂度是O(lgn)，一棵含有n个节点的红黑树的高度至多为2log(n+1).

HashTable与hashMap的不同

  HashTable线程安全，方法都是sychronized修饰;hashMap线程不安全；

  HashTable,Key和Value都不能为null;而hashMap可以有一个null可以，value是否为null无所谓;

  HashTable初始容量11，扩展2*n+1,HashMap,初始16，扩容加倍；初始容量向上取到2的N次方;

HashMap当链表长度大于阈值时，转化成红黑树，而HashTable没有。

ConcurrentHashMap的底层实现！！！！！！！！！！！！！！！

  HashMap多线程情况下，可能造成死循环，当扩容时，头插法+没有同步控制，很可能造成循环链表，造成死循环

  JDK1.8声明两对指针，维护两个链表，依次在末端添加新的元素,解决了死循环，但依然存在很多问题，例如数据丢失：

​    HashTable是线程安全的，使用synchronized来保证线程安全，锁住整个hash表，并发效率低下;

  JUC中的ConcurrentHashMap,1.5-1.7使用分段锁机制，将整个数组分割分段，每一把锁只锁定segment,

将整个Hash表切分多个Segment；而每个Segment元素，类似于一个Hashtable;

Segment的数量由所谓的concurrentcyLevel决定， 默认是16； 和HashMap的初始容量一致， 也可以在相应构造函数直接指定。 同样是2的幂数值;

  当一个线程占用锁访问其中一个segment的时候，其他segment也能被其他线程访问

  ConcurrentHashMap 定位一个元素的过程需要进行两次Hash操作，第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部

  JDK1.8之后，抛弃了segment的概念，直接用Node数组+链表+红黑树的数据结构实现，并发控制采用CAS+synchronize;

  put的时候, 判断是否kv为null, hash定位桶位置之后，如果为空，cas写入，否则synchronize加锁写入(更新或插入)如果链表长度达到8，将链表转化成红黑树；

  get的时候，没有并发控制；在链表查询的时候，会判断是红黑树还是链表，两种查询方式；

synchronize只锁定当前链表或红黑二叉树的首节点。

 

　　*①* *判断存储的**key**、**value**是否为空，若为空，则抛出异常，否则，进入步骤**②*

　　*②* *计算**key**的**hash**值，随后进入无限循环，该无限循环可以确保成功插入数据，若**table**表为空或者长度为**0**，则初始化**table**表，否则，进入步骤**③*

　　*③* *根据**key**的**hash**值取出**table**表中的结点元素，若取出的结点为空（该桶为空），则使用**CAS**将**key**、**value**、**hash**值生成的结点放入桶中。否则，进入步骤**④*

　　*④* *若该结点的的**hash**值为**MOVED**，则对该桶中的结点进行转移，否则，进入步骤**⑤*

　　*⑤* *对桶中的第一个结点（即**table**表中的结点）进行加锁，对该桶进行遍历，桶中的结点的**hash**值与**key**值与给定的**hash**值和**key**值相等，则根据标识选择是否进行更新操作（用给定的**value**值替换该结点的**value**值），若遍历完桶仍没有找到**hash**值与**key**值和指定的**hash**值与**key**值相等的结点，则直接新生一个结点并赋值为之前最后一个结点的下一个结点。进入步骤**⑥*

　　*⑥* *若**binCount**值达到红黑树转化的阈值，则将桶中的结构转化为红黑树存储，最后，增加**binCount**的值。*



### 15、正则表达式会写吗？ 

**^**匹配输入字符串开始的位置，$匹配输入字符串结尾的地方。

*，匹配前面字符0次或者多次。+，一次或多次匹配。？，零次或一次匹配。

{n},匹配前面n次，{n,}至少匹配n次。{n,m}至少匹配n次，至多匹配m次。

？：如果跟在其他通配符后面，表示非贪心搜索。其他的默认贪心匹配。O+?,表示只匹配一次o.而默认o+匹配所有o;

.，匹配任意字符。 X | Y，表示或，x或者y. [xyz]:字符集中的任意一个。[^xyz],反向字符集，匹配不包含字符的一个。

[a-z],匹配指定范围的任意字符。[^a-z]匹配非范围内的字符。 \d，数字字符匹配，[0-9]; \D,非数字字符匹配[^0-9];

\s,匹配任何空白字符。\S，匹配非空白字符。\w字母数字下划线，\W，非字符数字下划线。

 

常用正则表示式：

任意个数字：^[0-9]*$; n位数字：^\d{n}$; 中文：[\u4e00-\u9fa5]；非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$；带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$；由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 。**Email****地址：****^\w+([-+.]\w+)\*@\w+([-.]\w+)\*\.\w+([-.]\w+)\*$**

密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$

强密码(必须包含**大小写字母和数字的组合**，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$

IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)

IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))



### 16、设计模式了解吗？ 

设计模式

创建型模式、结构型模式和行为型模式 3 种。

创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。

结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。

行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。

单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，

工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。

抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。

代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。

适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。

策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。

职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。

观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。

迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。

 

UML图： 三格，上面类名，中间属性变量 -+#~表可见范围。下面是方法。接口有个O,没有正方形圈住。

依赖关系：------à A中引用了B的对象。关联关系 ——>如老师教学生这类关系

聚合关系：——白菱形。整体和部分关系，has-a;只不过部分可脱离整体存在，菱形的那边是整体。如汽车和轮子。

组合关系：——实体黑菱形。整体和部分的关系，部分不可脱离整体。黑菱形是整体。如头和嘴。

继承关系：——白三角，继承关系，老师继承人。

实现关系：------白三角：类实现了接口。

 

单例模式：生成单例的四种方式：懒汉模式，饿汉模式，多线程双重检验模式，静态内部类？

1、当一个类只要求生成一个对象的是场景。2、当对象需要被共享的场合。3、类对象需要频繁实例化又被频繁销毁。

关键点在于：隐藏构造方法， 开放一个静态方法，返回实例对象。有懒汉模式，饿汉模式，和多线程双重检验模式。

 

工厂模式：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体工厂实现类中。抽象工厂模式是工厂模式方法的升级版本，工厂方法模式只能产生一种产品，而抽象工厂模式可以生产多个等级的产品。

 

代理模式:在访问对象和目标对象之间创建一个代理对象，代理对象持有对代理对象的引用，访问对象通过代理对象间接访问目标对象。而且代理对象可以扩展目标对象的功能，还一定程度了降级了系统的耦合度。spring AOP是基于代理实现的，当被代理对象实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象， Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理.

 

 

 

原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。用Clone()方法直接赋值对象。

工厂模式：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。可以随时增加新的具体产品类和对应的具体工厂类。

抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。

代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。代理对象可以扩展目标对象的功能；客户端与目标对象分离，在一定程度上降低了系统的耦合度；代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；

动态代理：

 

适配器模式（Adapter）包含以下主要角色。

​    目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。

​    适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。

​    适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。

装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。

装饰模式主要包含以下角色。

抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。

具体构件（Concrete  Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。

抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。

具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

 

模板方法模式：

模板方法（Template Method）模式的定义如下：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。

 

Spring中用到的设计模式：

工厂设计模式

​    Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。

​    BeanFactory 采用了工厂设计模式，负责读取 bean 配置文档，管理 bean 的加载，实例化，维护 bean 之间的依赖关系，负责 bean 的生命周期。BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。

​    ApplicationContext 除了提供上述 BeanFactory 所能提供的功能之外，还提供了更完整的框架功能：国际化支持、资源访问，比如访问URL和文件、事件机制，同时加载多个配置文件等。ApplicationContext 在解析配置文件时对配置文件中的所有对象都初始化了，getBean() 方法只是获取对象的过程。

单例设计模式

​    Spring 中 bean 的默认作用域就是 singleton(单例)的。单例的好处：对于频繁使用的对象，可以省略创建对象所花费的时间；new 操作的次数减少，这将减轻 GC 压力，缩短 GC 停顿时间。

​    Spring 通 过 ConcurrentHashMap 实现单例注册表的特殊方式实现单例模式。

简单来说使用单例模式可以带来下面几个好处:

​    对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统

开销；

​    由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。

class Singleton{

  private volatile static Singleton instance;

  private Singleton(){

  }

  public static Singleton getInstance(){

​    if (instance == null){

​      synchronized (Singleton.class){

​        if (instance == null)

​          instance = new Singleton();

​      }

​    }

​    return instance;

  }

}

 

//懒汉模式，等你调用的时候才开始创建实例；懒加载启动快，资源占用小，使用时才实例化，无锁。非线程安全

class Singleton1{

  private static Singleton1 instance;

  private Singleton1(){

 

  }

  private static Singleton1 getInstacne(){

​    if (instance == null)

​      instance = new Singleton1();

​    return instance;

  }

 

}

 

//饿汉模式：

//优点：饿汉模式天生是线程安全的，使用时没有延迟。

//缺点：启动时即创建实例，启动慢，有可能造成资源浪费。

class Singleton2{

  private static Singleton2 instance = new Singleton2();

 

  private Singleton2(){}

 

  public Singleton2 getInstance(){

​    return instance;

  }

}

 

// Effective Java 第一版推荐写法

 

class Singleton23 {

 

  private static class SingletonHolder {

 

​    private static final Singleton23 INSTANCE = new Singleton23();

 

  }

 

  private Singleton23 (){}

 

  public static final Singleton23 getInstance() {

 

​    return SingletonHolder.INSTANCE;

 

  }

 

}

 

代理设计模式

​    AOP能够将那些与业务无关，**却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来**，便于**减少系统的重复代码**，**降低模块间的耦合度**，并**有利于未来的可拓展性和可维护性**。

​    **Spring AOP** **就是基于动态代理的****,** 如果要代理的对象，实现了某个接口，那么Spring AOP会使用**JDK Proxy**，去创建代理对象，而对于没有实现接口的对象， Spring AOP会使用 **Cglib** 生成一个被代理对象的子类来作为代理.

​    使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。

​    **Spring AOP** **属于运行时增强，而** **AspectJ** **是编译时增强。** Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作. Spring AOP 已经集成了 AspectJ , 如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。

 

模板方法

​    模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。

​    Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。

 

 

观察者模式：

​    观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。

Spring 事件驱动模型中的三种角色：事件角色、事件监听者角色、事件发布角色、

 

事件角色：`ApplicationEvent` (`org.springframework.context`包下)充当事件的角色,这是一个抽象类。

事件监听者角色：`ApplicationListener` 充当了事件监听者角色，它是一个接口，里面只定义了一个 `onApplicationEvent``（``ApplicationEvent E``）`方法来处理`ApplicationEvent``。```

ApplicationEventPublisher 充当了事件的发布者，它也是一个接口。publishEvent(ApplicationEvent event)

 

流程：

定义一个事件: 实现一个继承自 ApplicationEv ent，并且写相应的构造函数；

定义一个事件监听者：实现 ApplicationListener 接口，重写 onApplicationEvent() 方法；

使用事件发布者发布消息: 可以通过 ApplicationEventPublisher 的 publishEvent() 方法发布消息

 

适配器模式: 适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。

 

spring MVC中的适配器模式: 在Spring MVC中，`DispatcherServlet` 根据请求信息调用 `HandlerMapping`，解析请求对应的 `Handler`。解析到对应的 `Handler`（也就是我们平常说的 `Controller` 控制器）后，开始由`HandlerAdapter` 适配器处理。`HandlerAdapter` 作为期望接口，具体的适配器实现类用于对目标类进行适配，`Controller` 作为需要适配的类。

 

Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是`AdvisorAdapter``。通知有很多类型：`前置通知、后置通知、环绕通知、返回通知、异常通知。每种通知都有相对应的拦截器。Spring预定义的通知要通过对应的适配器，适配成 `MethodInterceptor`接口(方法拦截器)类型的对象（如：`MethodBeforeAdviceInterceptor` 负责适配 `MethodBeforeAdvice`）。

装饰者模式：

​    装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 `InputStream`家族，`InputStream` 类下有 `FileInputStream` (读取文件)、`BufferedInputStream` (增加缓存,使读取文件速度大大提升)等子类都在不修改`InputStream` 代码的情况下扩展了它的功能。Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。



### 17、linux指令知道哪些？

Linux相关

查看进程PID 

根据名称匹配：Ps -ef | grep xxxx

根据端口号 ： lsof -i:5000

关闭xxx的进程 ： kill -9 xxxx; 9：SIGKILL，强制中断一个进程的进行;

top 命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器;

chmod命令, chown,chgrp

cat　用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示.more,less，按页查看，前翻后翻。

tail: 从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容.

diff 命令用于比较两个文件或目录的不同

scp 命令是secure copy的简写，用于在Linux下进行远程拷贝文件的命令;

ssh远程登录；

ping; ifconfig

grep命令:该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来

grep -n '要查找的字符串' 被查的文件file:返回行数；

 

cp复制，rm删除，mv移动，tar解压缩，mkdir，rmdir,

、



## 多线程并发

### 1、进程线程区别，线程安全和非线程安全区别 

​    进程是程序运行的实例。运行一个Java程序的实质就是启动一个java虚拟机进程。进程是程序向操作系统申请资源的基本单位。线程是进程中可独立执行的最小单位。一个进程可以包括多个线程，同一个进程中的所有线程共享该进程的资源。

​    竞态：多线程编程中一个问题，对于同样的输入，程序的输出有时是正确的，有时是错误的，这种计算结果的正确性与时间有关的现象被成为竞态。

​    线程安全和非线程安全： 一个类在单线程环境下能够正常运行，并且在多线程环境下，使用方不做特别处理也能运行正常，我们就称其实线程安全的。反之，一个类在单线程环境下运行正常，而在多线程环境下无法正常运行，这个类就是非线程安全的。

 

### 2、线程状态，start,run,wait,notify,yiled,sleep,join等方法的作用以及区别 

​    线程状态：新建（new之后），就绪（start之后），运行（run之后），阻塞（等待，wait/sleep,阻塞IO/申请锁，有限等待），死亡。

​    多线程实现方式:1.实现Runnable接口2、继承Thread类。因为java不支持多重继承，但可以实现多个接口。所有实现Runnable有更好的扩展性；还可以实现资源个共享，即多个线程基于一个Runnable对象，和共享Runnable的资源。

第三种是实现Callable接口;将实现类当做线程中运行的任务，然后用Thread来调用。callable的call方法有返回值，通过FutureTask进行封装。

  A.start()是启动一个新线程A,进入就绪状态。start方法只能被调用一次。

  ==Run()方法，是就绪状态的线程获取cpu之后调用的，线程进入运行状态。如果手动调用，相当于执行一个普通方法。==

  Java中，每个对象有且只有一个同步锁。调用synchronized方法就获取了对象的锁。

  当一个线程访问对象的同步方法或者同步代码块，其他线程不能再访问该对象的同步方法或者同步代码块，但可以访问该对象的非同步方法或者非同步代码块。

t1.wait(),让当前线程进入阻塞状态，释放t1对象的锁，直到其他线程调用t1.notify()方法，当前运行线程才可能被唤醒。



### 3、wait,notify阻塞唤醒确切过程？在哪阻塞，在哪唤醒？为什么要出现在同步代码块中，为什么要处于while循环中？ 

wait()和notify()方法必须出现在同步代码块中，等待和唤醒是依赖于同步锁实现的，同步锁是对象持有，每个对象有且只有一个。所以wait要释放锁，因为之后他释放了该锁，其他对象才能获取该锁，然后进入同步代码中，notify该对象上等待的对象。所以这也就是wait和notify方法为什么出现在Object对象上。

  yield()：Thread静态方法，表示当前线程从运行状态转入就绪状态，给其他线程竞争的机会。不会释放任何锁。

  sleep()：Thread静态方法，当前线程从运行状态进入等待阻塞状态，不释放任何锁，休眠一段时间后，该线程进入就绪状态。单位毫秒

  A.join()：当前线程进入阻塞状态，等线程A执行完之后，当前线程从阻塞状态进入就绪状态。

  线程优先级，1-10，默认5.用户线程，守护线程，isDaemon() t1.setDaemon(true);用户线程运行时，jvm不得关闭。gc线程是守护线程。



### 4、线程中断，守护线程 

  中断：调用线程的A.interrupt()方法，会设置线程A的中断标记为true。如果线程A处于wait(),join(),sleep()等阻塞状态时（不是io阻塞和锁阻塞），清除中断标记，抛出InterruptedException,线程结束。

  A.interrupted()方法，查看线程是否处于中断状态。且清除中断标记，而isInterrupted则查看中断标记，不会清除。

  Executor的中断，shutdown()，不再接受新任务，等待线程池中所有的任务完成。shutdownNow(),不接受新的，和未处理的。调用每个正在执行线程的interrupt()；

   中断线程池中的一个线程：使用submit方法提交线程，会返回一个future对象，调用该对象的cancel(true)方法中断线程。



### 5、Java乐观锁机制，CAS思想？缺点？是否原子性？如何保证？ 

悲观锁和乐观锁

  乐观锁：每次访问数据的时候都认为其他线程不会修改数据，所以直接访问数据，更新的时候再判断在此期间其他线程是否修改数据。CAS和版本号机制是乐观锁的实现。

  乐观锁适合多读场景，悲观锁适合多写情况。

  版本号机制:数据有个version字段，表示被修改的次数。

CAS:无琐算法，非阻塞同步，需要读写的内存值V和旧的期望值A相同时，更新为B.一般都是自旋CAS,不断的重试。乐观锁缺点：1、ABA问题（加入版本号机制）。2、自旋CAS如果一直不成功，开销大。3、只对单变量有效，当涉及多个共享变量时，无效。

乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。CAS是通过硬件命令保证了原子性。

​    

​    悲观锁：每次访问数据的时候都会认为其他线程会修改数据，所以先获取锁，再访问数据。synchronized和ReentrantLock都是悲观锁思想的实现。



### 6、synchronized使用方法？底层实现？

​    Synchronized关键字三种实现方式：

  修饰实例方法，对当前实例对象加锁，进入同步代码前要获取对象实例的锁。修饰静态方法，对当前类对象加锁，修饰代码块，指定加锁对象，给对象加锁。

  具体实例，双重校验锁实现对单例模式;

   Synchronized同步的实现，是基于进入退出监视器Monitor对象实现的，无论是同步代码块还是同步方法，都是如此；同步代码块，是根据monitorenter 和 monitorexit 指令实现的，同步方法，是通过设置方法的 ACC_SYNCHRONIZED 访问标志;监视器Monitor对象存在于每个对象的对象头中。



### 7、ReenTrantLock使用方法？底层实现？和synchronized区别？ 

  两者都是可重入锁(自己可以再次获取自己的内部锁)，锁计数器加1;

  synchronized只能是是非公平锁，而ReenTrantLock默认实现非公平锁，也支持公平锁(先等先得)

   synchronized依赖于JVM实现，而ReenTrantLock是基于JDK实现的;

  ReenTrantLock功能加多：1、等待可中断，2、支持公平锁，3、基于Condition实现选择性唤醒;

synchronized经过一系列的优化，性能已得到大大的提升，和ReenTrantLock相差无几。

  

ReentrantLock,可重入互斥锁，独占锁。互斥锁：同一时间只能被一个线程持有。可重入锁：可以被单个线程多次获取。ReentrantLock支持公平锁和非公平锁，Synchronized只支持非公平锁。公平锁：线程依次排队获取锁。非公平锁：不管是不是队头都能获取。公平锁和非公平锁，它们尝试获取锁的方式不同：公平锁在尝试获取锁时，即使“锁”没有被任何线程锁持有，它也会判断自己是不是CLH等待队列的表头；是的话，才获取锁。而非公平锁在尝试获取锁时，如果“锁”没有被任何线程持有，则不管它在CLH队列的何处，它都直接获取锁。



### 8、公平锁和非公平锁区别？为什么公平锁效率低？ 

公平锁要维护一个队列，后来的线程要加锁，即使锁空闲，也要先检查有没有其他线程在 wait，如果有自己要挂起，加到队列后面，然后唤醒队列最前面的线程。这种情况下相比较非公平锁多了一次挂起和唤醒。

线程切换的开销，其实就是非公平锁效率高于公平锁的原因，因为非公平锁减少了线程挂起的几率，后来的线程有一定几率逃离被挂起的开销。



### 9、锁优化。自旋锁、自适应自旋锁、锁消除、锁粗化、偏向锁、轻量级锁、重量级锁解释 

JDK1.6引入了大量的锁优化:偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术减少开销。

  锁主要存在4种状态：无琐状 态，偏向锁状态，轻量级锁状态，重量级锁状态 。锁可升级不可降级，提供获取锁和释放锁的效率。

​    自旋锁:进程进入阻塞的开销很大，为防止进入阻塞状态，在线程请求共享数据锁的时候循环自旋一段时间，如果在这段时间内获取到锁，就避免进入阻塞状态了。

  1.6引入自适应自旋锁，自旋次数不再固定：由锁拥有者状态和上次获取锁的自旋次数决定。

  锁消除：对于被检测出不可能存在竞争的共享数据的锁进行消除。(逃逸分析)

  锁粗化:虚拟机探测到一系列连续操作都对同一个对象加锁解锁，就将加锁的范围粗化到整个操作系列的外部。

  偏向锁：当锁对象第一次被线程获取的时候，进入偏向状态，标记为101，同时CAS将线程ID进入到对象头的Mark Word中，如果成功，这个线程以后每次获取锁就不再需要进行同步操作，甚至CAS不都需要。当另一个线程尝试获取这个锁，偏向状态结束，恢复到未锁定状态或者轻量级状态。

  轻量级锁：对象头的内存布局Mark Word,有个tag bits,记录了锁的四种状态:无琐状态，偏向锁状态，轻量级锁状态，重量级锁状态.轻量级锁相对重量级锁而言，使用CAS去避免重量级锁使用互斥量的开销。线程尝试获取锁时，如果锁处于无琐状态，先采用CAS去尝试获取锁，如果成功，锁状态更新为轻量级锁状态。如果有两条以上的线程争用一个锁，状态重为重量级锁。



### 10、Java内存模型 

Java内存模型:数据主要存放在主内存中，为了加快对内存的数据处理，在cpu和内存中间，加入了寄存器，存储器，高速缓存等处理器缓存;从多线程角度，可以把内存模型简化成:主内存和线程本地内存。线程可以把变量从主内存读取到本地缓存中，然后再本地缓存中进行读写，然后将改变结果写入到内存中。这就导致线程本地内存和主内存数据不一致的情况。即可见性。volatile可解决这个问题。



### 11、volatile作用？底层实现？禁止重排序的场景？单例模式中volatile的作用？ 

Volatile变量在汇编阶段，会多出一条lock前缀指令，这会导致当前处理器缓存的数据写回到系统内存中，且让其他改数据的处理器缓存失效。这就保障了可见性

  Volatile的修饰的变量，虚拟机会使用内存屏障禁止指令重排序保障其有序性。但volatile变量不能保证其原子性。所以volatile是线程同步的轻量级实现，性能好，多线程访问volatile变量不会发生阻塞，volatile变量主要用于变量在多线程之间的可见性。但并不能保障原子性，不可替代synchronized.synchronized解决的是多线程之间访问共享资源的同步性。

​    ThreadLocal,线程本地存储，提供了一个线程局部变量，让访问某个变量的线程都拥有自己的线程局部变量，这样线程对变量的访问就不存在竞争问题，也不需要同步。每个线程都有一个ThreadLocal.ThreadLocalMap对象。map的键是ThreadLocal t = new ThreadLocal()，值是value。ThreadLocalMap的Entry节点的key指向ThreadLocal是弱引用，虚拟机只要发现就可以垃圾回收。

  Thread -> ThreadLocalMap -> Entry<ThreadLocal,value> ---> ThreadLocal(key弱引用到ThreadLocal);

  所以ThreadLocal设置为null,ThreadLocal只有弱引用，可以被回收，但value存在强引用，不能被回收。

  如何避免？事实上，ThreadLocalMap的get,set方法中，会对key（ThreadLocal）进行null判断，如果为null,value也设置为null.也可以手动条调用ThreadLocal.remove()方法。



### 12、AQS思想，以及基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore介绍

AQS与JUC

AQS(AbstactQueuedSynchronizer)同步队列器，是一个构建锁和同步器的框架，使用AQS能够简单有效的构造出应用广泛的大量同步器。如ReentrantLock, Semphore>

AQS原理：如果被请求的共享资源空闲，则将当前请求线程设为有效的工作线程，并且将共享资源设置为锁定状态。如果请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的。即将暂时获取不到的线程放入队列中。CLH,是虚拟的双向队列，即不存在队列实例，仅存在节点与节点之间的pre和next关系。AQS将每条请求共享资源的线程封装成一个CLH锁队列的一个节点来实现锁的分配。

 AQS属性(Node head, Node tail, int state（这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁）, Thread 持有独占锁的线程)；

 等待队列中每个线程被封装为一个Node实例（thread + waitStatus(-1: 当前node的后继节点对应的线程需要被唤醒,) + pre + next）；

​    State:表示当前锁的状态，等于0时，表示没有被线程占用。当大于0时，表示被线程占用。

​    Node节点的属性 watiStatus:默认为0，当大于0时，表示放弃等待，ReentrantLock是可以指定timeouot的。等于-1，表示当前node的后继节点对应的线程需要被唤醒。当等于-2时，标志着线程在Condition条件上等待的线程唤醒。等于-3时，用于共享锁，标志着下一个acquireShared方法线程应该被允许。

公平锁，只有处于队头的线程才被允许去获取锁。非公平性锁模式下线程上下文切换的次数少，因此其性能开销更小。公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。

 

AQS组件：

AQS类别：独占锁和共享锁。

​    共享锁有ReentrantReadWriteLock、CountDownLatch、CyclicBarrier、Semaphore:

  ReadWriteLock，读写锁。维护了一对相关联的读取锁和写入锁。读取锁用于只读操作，共享。写入锁用于写入操作， 是独占锁。不能同时存在读取锁和写入锁。

   CountDownLatch(lætʃ)是通过共享锁实现的;CountDownLatch doneSignal = new CountDownLatch(LATCH_SIZE);

   CountDownLatch对象维护一个count,执行一次doneSignal.countDown()时，count减一直到count为0时， doneSignal.await()的等待线程才能运行。所以countDownLatch可以让一个线程等待一组线程完成之后才执行。

​    CyclicBarrier(ˈsaɪklɪk ˈbæriər) cb = new CyclicBarrier(SIZE);调用线程创建N个齐头并进的CyclicBarrier对象。每个线程执行cb.await()时，参与者数量加一，当参与者数量达到SIZE，阻塞的参与线程继续运行。

  (01) CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待,直到到达某个公共屏障点.

  (02) CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。

  Semaphore(ˈseməfɔːr) sem = new Semaphore(SEM_MAX);建立N个信号量。 sem.acquire(count);获取count个信号量。如果有就给予，没有就阻塞。sem.release(count);释放信号量。

​    

JUC原子类  基本类型：AtomicInteger,AtomicLong,AtomicBoolean;数组类型AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray;引用类型，对象属性修改类型。在32位操作系统中，64位的long 和 double 变量由于会被JVM当作两个分离的32位来进行操作，所以不具有原子性；

​    原子类基本通过自旋CAS来实现，期望的值和现在的值是否一致，如果一致就更新。

​    public final boolean compareAndSet(long expect, long update) {

​      return unsafe.compareAndSwapLong(this, valueOffset, expect, update);

​    }

​    主要利用CAS+volatile + native方法来保证操作的原子性，从而避免同步方法的高开销。CAS原理是那期望的值和现在的值进行比较，如果相同则更新成新的值。



### 13、线程池构造函数7大参数，线程处理任务过程，线程拒绝策略 

### 14、Execuors类实现的几种线程池类型，阿里为啥不让用？ 

### 15、线程池大小如何设置？ 

​    线程池则是为了减少线程建立和销毁带来的性能消耗。线程池的使用可以帮助我们更合理的使用系统资源.

​    Executors是个静态工厂类。它通过静态工厂方法返回ExecutorService、ScheduledExecutorService、ThreadFactory 和 Callable 等类的对象。

  Executor ɪɡˈzekjətər只提供了execute()ˈeksɪkjuːt接口来执行已提交的 Runnable 任务的对象。

  ExecutorService接口，继承Executor,AbstractExecutorService抽象类实现了ExecutorService接口。  ThreadPoolExecutor，真正线程池实现类。

  ThreadPoolExecutor是线程池类。对于线程池，可以通俗的将它理解为"存放一定数量线程的一个线程集合。线程池允许若个线程同时运行;

  当添加的到线程池中的线程超过它的容量时，会有一部分线程阻塞等待。线程池会通过相应的调度策略和拒绝策略，对添加到线程池中的线程进行管理。

  关闭线程池：调用线程池的shutdown()接口时，线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。

   调用线程池的shutdownNow()接口时，线程池切换为STOP状态，不接收新任务，不处理已添加的任务，并且通过调用每个线程的interrupt()方法尝试中断正在处理的任务。

一定要通过 ThreadPoolExecutor(xx,xx,xx...) 来明确线程池的运行规则，指定更合理的参数。

​    ThreadPoolExecutor线程池的7大参数：

​    kɔːr corePoolSize：核心池的大小：创建线程池之后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；调用了prestartAllCoreThreads()或者prestartCoreThread()方法，可以在任务来之前预创建线程。核心线程会一直存活，及时没有任务需要执行；

设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭；

maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；

keepAliveTime：非核心线程的最大空闲时间。

TimeUnit：空闲时间的单位。

BlockingQueue<Runnable> workQueue ：等待执行的任务队列，队列分为有界队列和无界队列。有界队列：队列的长度有上限，当核心线程满载的时候，新任务进来进入队列，当达到上限，有没有核心线程去即时取走处理，这个时候，就会创建临时线程。（警惕临时线程无限增加的风险）

无界队列：队列没有上限的，当没有核心线程空闲的时候，新来的任务可以无止境的向队列中添加，而永远也不会创建临时线程。（警惕任务队列无限堆积的风险）

ThreadFactory：线程工厂，用来创建线程

RejectedExecutionHandler：队列已满，而且任务量大于最大线程的异常处理策略

 

线程池属性属性：

largestPoolSize，记录了曾经出现的最大线程个数。因为setMaximumPoolSize()可以改变最大线程数。

poolSize：线程池中当前线程的数量。

当提交一个新任务时：

（1）如果poolSize<corePoolSize，新增加一个线程处理新的任务。无论是否有空闲的线程新增一个线程处理新提交的任务；

（2）如果poolSize=corePoolSize，新任务会被放入阻塞队列等待。

（3）如果阻塞队列的容量达到上限，且这时poolSize<maximumPoolSize，新增线程来处理任务。

（4）如果阻塞队列满了，且poolSize=maximumPoolSize，那么线程池已经达到极限，会根据饱和策略RejectedExecutionHandler拒绝新的任务。

 

\* 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize

\* 如果allowCoreThreadTimeout=true，则会直到线程数量=0

 

workQueue：一个阻塞队列：ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous；

workQueue的类型为BlockingQueue<Runnable>，通常可以取下面三种类型：

　　1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；

　　2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；

　　3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。

 

线程拒绝策略：

ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 

ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 

ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）

ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务

 

ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：

shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务

shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务

 

动态调整大小：

setCorePoolSize：设置核心池大小

setMaximumPoolSize：设置线程池最大能创建的线程数目大小

 

其他种类的：Executor框架的工具类Execuors来实现。

newFixedThreadPool：建立一个线程数量固定的线程池，规定的最大线程数量，超过这个数量之后进来的任务，会放到等待队列中，如果有空闲线程，则在等待队列中获取，遵循先进先出原则。corePoolSize 和 maximumPoolSize 要一致，Executors 默认使用的是 LinkedBlockingQueue 作为等待队列，这是一个无界队列。

newSingleThreadExecutor：建立一个只有一个线程的线程池，如果有超过一个任务进来，只有一个可以执行，其余的都会放到等待队列中，如果有空闲线程，则在等待队列中获取，遵循先进先出原则。使用 LinkedBlockingQueue 作为等待队列。等待队列无限长的问题，容易造成 OOM。

newCachedThreadPool：缓存型线程池，在核心线程达到最大值之前，有任务进来就会创建新的核心线程，并加入核心线程池，即时有空闲的线程，也不会复用。达到最大核心线程数后，新任务进来，如果有空闲线程，则直接拿来使用，如果没有空闲线程，则新建临时线程。并且线程的允许空闲时间都很短，如果超过空闲时间没有活动，则销毁临时线程。关键点就在于它使用 SynchronousQueue 作为等待队列，它不会保留任务，新任务进来后，直接创建临时线程处理。容易造成无限制的创建线程，造成 OOM。

newScheduledThreadPool：计划型线程池，可以设置固定时间的延时或者定期执行任务，同样是看线程池中有没有空闲线程，如果有，直接拿来使用，如果没有，则新建线程加入池。使用的是 DelayedWorkQueue 作为等待队列，这中类型的队列会保证只有到了指定的延时时间，才会执行任务。容易造成无限制的创建线程，造成 OOM。

 

线程池大小如何设置？

对于计算密集型的任务，一个有Ncpu个处理器的系统通常通过使用一个Ncpu + 1个线程的线程池来获得最优的利用率.

对于包含了 I/O和其他阻塞操作的任务，不是所有的线程都会在所有的时间被调度，因此你需要一个更大的池。2*Ncpu

　　Nthreads = Ncpu x Ucpu x (1 + W/C)，其中

　　Ncpu = CPU核心数

　　Ucpu = CPU使用率，0~1

W/C = 等待时间与计算时间的比率

线程数 = Ncpu /（1 - 阻塞系数）= Ncpu x (1 + W/C)

线程数设置过大有什么缺点：

​    如果maxsize过大会占用更多资源，cpu会频繁地进行上下文切换，会导致cpu缓存的数据失效和重新加载，结果就是上下文切换和reload的时间变多，也就是说cpu将更多的时间花费到对线程的管理上去了，这时候更多的线程反而更慢



## Redis

### 1、为什么使用Redis 

Redis,key-Value类型的内存数据库，整个数据库系统在内存中操作，定期异步flush到硬盘上进行保存。常用于缓存，也可以作分布式锁。redis提供多种数据类型，支持事务，两种持久化方式，多种集群方案。

  **Redis** 为什么要作为缓存？ 高性能和高并发：

  **高性能**：用户第一次访问数据库时，是从硬盘上读取的，过程比较慢，效率比较低。redis作为缓存，将用户访问的诗句存在缓存中，下一次再访问这些数据时就可以直接从缓存中读取了，操作缓存就是直接存在内存，速度特别快。

  **高并发:**直接操作缓存所能承受的请求远远大于直接访问数据库的。把数据库的部分数据存在缓存中，可提供并发能力



### 2、分布式缓存和本地缓存有啥区别？让你自己设计本地缓存怎么设计？如何解决缓存过期问题？如何解决内存溢出问题？ 

redis/memcached分布式缓存和map/guava本地缓存的区别:

  缓存分为本地缓存和分布式缓存，使用map或guava的是本地缓存，轻量而快速，随着jvm的销毁而结束，多实例情况下，每个实例都保存一份缓存，缓存不具有一致性。

  分布式缓存，多实例情况下，各实例共用一份缓存数据，缓存具有一致性。缺点，架构复杂，要保证服务的高可用。



### 3、redis和memcached的区别

   redis和memcached的区别:

  1、redis支持更丰富的数据类型：redis不仅仅支持简单的k/v类型的数据，同时还提供list,set,zset,hash等数据结构的存储，memcached仅支持简单的数据类型，string.

  2、reids支持数据的持久化，可以将内存中的数据保存到磁盘中，重启的时候可以再次加载使用，而memcached不支持持久化。

  3、集群模式，memcached没有原生的集群模式，redis目前是原生支持cluster模式的。

  4、memcached是多线程，非阻塞IO复用的网络模型;Redis使用单线程的多路IO复用模型。

  5、redis支持主从同步

 

### 4、redis常用数据结构和使用场景 

  redis常用数据结构以及场景。

  string,hash,list,set,zset;key都是string,但value是多种数据结构的。

​    数据类型：

​    String: set、get、decr、incr、

​    hash(将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在redis里);hget,hset,hgetall

​    List,粉丝列表；存储一些列表型的数据结构，类似粉丝列表了、文章的评论列表。以通过lrange命令，就是从某个元素开始读取多少个元素，可以基于list实现分页查询。）lpush,rpush,lpop,rpop,lrange

​    Set：无序集合，自动去重set玩儿交集、并集、差集的操作，比如交集吧，可以把两个人的粉丝列表整一个交集，看看俩人的共同好友是谁。Sadd, Spop, Sunion, sinterstore(交集)

​    Sorted Set，去重但是可以排序；最大的特点是有个分数可以自定义排序规则。Zadd,Zrange,zcard

   

### 5、Zset底层实现？跳表搜索插入删除过程？

 底层实现：

​    简单动态字符串SDS:char[]数组加len属性和free属性（记录数组中未使用的字节数）；直接获取长度，防止溢出，

​    Redis还实现了双端链表，双端，无环，带长度属性len;

​    Redis 的字典使用哈希表作为底层实现。链地址法解决冲突的哈希表实现的。

​    跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。跳跃表通常是有序集合的底层实现之一，表中的节点按照分值大小进行排序。

  1、由很多层结构组成；

　　   2、每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；

　　3、最底层的链表包含了所有的元素；

 　4、如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；

　　5、链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；

跳跃表的操作过程：

​    ①、搜索：从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。

　　②、插入：首先确定插入的层数，有一种方法是假设抛一枚硬币，如果是正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数。当确定插入的层数k后，则需要将新元素插入到从底层到k层。

　　③、删除：在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。

​    ziplist编码的有序集合使用紧挨在一起的压缩列表节点来保存，第一个节点保存member，第二个保存score。ziplist内的集合元素按score从小到大排序，score较小的排在表头位置。

​    skiplist编码的有序集合底层是一个命名为zset的结构体，而一个zset结构同时包含一个字典和一个跳跃表。跳跃表按score从小到大保存所有集合元素。而字典则保存着从member到score的映射，这样就可以用O(1)的复杂度来查找member对应的score值。虽然同时使用两种结构，但它们会通过指针来共享相同元素的member和score，因此不会浪费额外的内存。跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度。

 

### 6、redis过期淘汰策略 

  redis可以为key设置过期时间,对过期的key,采用定期删除和惰性删除的方式。

  定期删除：每100ms，随机抽取一些设置过期时间的key,检查是否过期，如过期，则删除。

惰性删除：一些过期的key,并没有被定性删除删除掉，只有当系统使用并检查其过期了，才会将其删除。

 

  大量key到内存中，达到redis内存最大值，会进行内存淘汰机制。

   Redis数据淘汰策略:noeviction,内存达到最大值，直接返回错误。allkeys-lru:所有键里最近最少使用;

  allkeys-random:所有键随机回收；volatile-lru:设置过期时间的键中，回收最近最少使用的，volatile-random:设置过期集合键中，随机回收。

   volatile-ttl:设置过期时间的键中，回收存活时间较短的键。



### 7、redis持久化机制？都有什么优缺点？持久化的时候还能接受请求吗？ 

   redis持久化机制：redis持久化就是将内存中的数据写入到硬盘中，为了备份重用数据。支持两种持久化方式，快照RDB和只追加文件AOF;

  快照RDB,通过创建快照获得某个时间点的数据副本，可以对快照进行备份，或者复制到其他机器重用数据。默认的持久化方式。save 900 20,在15分钟之后，有20个key变化，触发快照。

AOF,实时性更好，主流方案，默认没有开启。开启后，每执行一条更改redis数据的命令，都将该命令写入磁盘的AOF中。三种AOF方式， always,每次修改都写入AOF; everysec,每秒钟同步一次，多个命令一次写入。 no,操作系统决定何时同步。

RDB优缺点：每个RDB都代表了某一时刻redis的数据，适合做冷备份，且恢复数据速度快。缺点：实时性不好，可能会丢失部分数据，如果文件过大， 可能会导致提供的服务暂停几秒。

AOF优缺点：实时性好，一般1s一写入，而且写入性能比较好。缺点:AOF文件更大，开启后QDS相对来说比较低，恢复速度慢。

​    综合AOF和RDB两种持久化方式，用AOF来保证数据不丢失，作为恢复数据的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，可以使用RDB进行快速的数据恢复。

 

### 8、redis事务

  redis事务。redis使用MULTI、EXEC、WATCH等命令实现事务功能。MULTI开始事务，EXEC，执行事务。DISCARD取消事务，WATCH监视key;

  单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。

  事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。



### 9、缓存雪崩和缓存穿透，以及解决方法 

  缓存雪崩和缓存穿透

  缓存雪崩，缓存在同一时间内大面积失效，所有的请求都落在数据库中，数据库短时间内承受大量请求而崩掉。

  缓存同一时间内失效课可能是服务器宕机或者设置了相同时间过期的key同时失效。

  事前，尽量保证redis集群的高可用性，key的过期时间尽可能错开。

  事中，本地ehcache缓存(先查本地缓存再查redis,然后数据库)+hystrix限流(每秒就接受一定量的请求)&降级(多余的请求走降级组件);

  事后，利用持久化机制恢复缓存。

 

  缓存穿透，查询一个根本不存在的数据，缓存层和数据库都不命中，失去了缓存的意义。

  解决方案1、对空结果作缓存，意味着设置更多的键，占用更多的内存，所以要过期时间设置很短。

  2、布隆过滤器：将所有可能存在数据哈希到一个bitMap中，拦截不存在的数据访问，缺点有一定的误识别率。

 

  并发竞争key问题，多个系统同时对一个key进行操作,执行顺序不同导致与期望结果不同。使用分布式锁解决。

  redis实现分布式锁。

  zookeeper实现分布式锁。

 

### 10、如何保证缓存和数据库的数据一致性？

如何保证缓存和数据库双写时的数据一致性？

  当发生数据修改时，是先更新数据库还是先更新缓存。缓存的更改是更新缓存还是直让原有缓存失效。

一般来说是先更新数据库，然后让缓存失效，将失效信息发送到mq中，mq不断的重试让缓存失效，保证缓存和数据库的数据一致性。

先删除缓存，再更新数据库：A写然后删除缓存，然而B查询缓存不存在，查询数据库得到旧值，然后缓存旧值。然后A更新数据库。这就造成了数据库和缓存不一致。这时采用延时双删策略：先删除缓存，然后更新数据库，然后休眠一段时间内如1s，再删除缓存。淘汰这一段时间的缓存脏数据。

 如果mysql采用了读写分离：也会造成数据不一致。A想写，先删缓存，然后写入数据库。B读请求，没有缓存，读取从库旧值，然后缓存旧值，数据库主从同步。还可以采用延时双删的策略，延时的时间长点，完成主从同步。

采用这种同步淘汰策略，吞吐量降低怎么办？第二步的删除作为异步，启动一个线程去删除。

第二次删除,如果删除失败怎么办？

 

先更新数据库，再删除缓存

缓存更新套路：

 失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。

命中：应用程序从cache中取数据，取到后返回。

更新：先把数据存到数据库中，成功后，再让缓存失效。

缓存刚好失效，A做查询，得到旧值，B做更新，让缓存失效。A将旧值缓存。但由于B是更新然后让缓存失效，这一耗时明显大于A查询然后缓存旧值，所以出现不一致的概率很低。如果非要解决，就用延时双删，再删除一次呗。

所以，如果删除缓存失败怎么办？

 提供一个保障的重试机制即可。一、将需要删除的key发送给消息队列，保证其删除成功。

二、降低耦合性的方案：（1）更新数据库数据（2）数据库会将操作信息写入binlog日志当中（3）订阅程序提取出所需要的数据以及key（4）另起一段非业务代码，获得该信息（5）尝试删除缓存操作，发现删除失败（6）将这些信息发送至消息队列（7）重新从消息队列中获得该数据，重试操作。

   

### 11、redis是单线程还是多线程？为什么那么快？

redis是单线程的，为什么还那么快？

  1、操作完全基于内存，速度快。

  2、数据结构简单，对数据的操作也简单。

  3、**处理网络请求采用单线程**（并不是内部只有一个线程），避免了不必要的上下文切换开销和锁的竞争，想多多核也可以利用多个实例。

  4、使用非阻塞的多路IO复用模型。

### 13、select、poll、epoll的区别？

​    I/O 多路复用模型是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。

​    I/O多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。

​    select缺点：每次调用select，都需要把fd_set集合从用户态拷贝到内核态，都需要在内核遍历传递进来的所有fd_set，且内核对被监控的fd_set集合大小做了限制，为1024。

​    poll缺点：poll没有最大文件描述符数量的限制，其他缺点和select一样。数据结构变成了pollfd

​    epoll: 最大连接数没有限制，采用事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面



### 12、五种IO模型的区别 

​    Unix五种IO模型：

阻塞IO, 网络编程中，读取客户端的数据需要调用recvfrom。在默认情况下，这个调用会一直阻塞直到数据接收完毕，就是一个同步阻塞的IO方式。内核准备数据，并将数据从内核拷贝到用户内存，内核返回结果，用户进程再解除阻塞状态，重新运行起来。

非阻塞IO：用户进程调用recvfrom之后，如果内核数据没有准备好，并不会阻塞用户进程，而是立即返回数据未准备好的结果，用户进程以后不断调用recvfrom来轮询内核是否准备好数据。信号驱动IO,调用之后，不等待数据就绪立即返回，等内核准备好数据之后，发送信号给用户进程。

异步IO, 读取操作(aio_read)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。

对比信号驱动IO，异步IO的主要区别在于：信号驱动由内核告诉我们何时可以开始一个IO操作(数据在内核缓冲区中)，而异步IO则由内核通知IO操作何时已经完成(数据已经在用户空间中)。

IO多路复用：可以处理多个连接。这里的select相当于一个“代理”，调用select以后进程不会被select阻塞，这时候在内核空间内select会监听指定的多个datagram (如socket连接)，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。由于select可以监听多个socket，我们可以用它来处理多个连接。

 

### 14、redis热key问题？如何发现以及如何解决？

redis热key问题：某个key被大量访问，对redis服务器造成了很大的压力。

解决方案：

1、服务端缓存：即将热点数据缓存至服务端的内存中，利用 ehcache ，或者一个 HashMap 都可以。在你发现热key以后，把热key加载到系统的JVM中。针对这种热key请求，会直接从jvm中取，而不会走到redis层。这个可能发生缓存和redis数据不一致的情况。利用Redis自带的消息通知机制，对于热点Key建立一个监听，当热点Key有更新操作的时候，缓存也随之更新。

2、备份热key, 即将热点Key+随机数，随机分配至Redis其他节点中。这样访问热点key的时候就不会全部命中到一台机器上了。（Redis集群中包含了16384个哈希槽(Hash slot)，集群使用公式CRC16(key) % 16384来计算Key属于哪个槽。那么同一个Key计算出来的值应该都是一样的，如何将Key分到其他机器上呢？只要再后面加上随机数就行了，这样就能保证同一个Key分布在不同机器上）

这都是知道热key是什么的情况，那么如何发现热key?

1、经验预估。2、Redis自带命令查询：Redis4.0.4版本提供了`redis-cli –hotkeys`就能找出热点Key.

3、客户端收集：在操作Redis之前对数据进行统计。

 

### 15、redis数据分布方式？有什么优点？一致性hash呢？ 

redis集群数据迁移方式

  redis集群并没有使用一致性hash,而是使用数据分片引入哈希槽来实现。

   redis集群共有16384个哈希槽，所有的键都将映射到哈希槽中，使用CRC16(key)%16384=哈希槽，集群按槽分片，每个节点指派不同数量的槽。

一致性hash,是将整个hash值空间0-2^32-1组成一个虚拟圆环，key的哈希函数对2^32取模得到哈希值，在圆环上顺时针转，遇到的第一个服务器就是定位到的服务器。这样即使增加或减去一个服务器，对数据的影响比较小，数据迁移也比较简单。缺点：在某些极端情况下，可能数据扎堆分布在一个服务器上，当这个服务器出现问题，对整个系统的影响依然很大。针对分配不均的情况下，提出了虚拟节点，将服务器后面的ip或主机名后面增加编号，生成多个虚拟节点，分配到虚拟节点的数据实际上是分配到了该服务器上。

普通的分布式缓存策略是：hash(obj)%N。当其中一个服务器宕机或者需要新增一个服务器时，缓存策略变为hash(obj)%(N-1);就意味着，所有的缓存都将失效。必定会造成缓存数据的丢失，会去向后端的服务器去请求。增加删除服务器时，代价比较大，所有的数据不得不根据id再次计算哈希值，然后%N,进行重新分配和大规模数据迁移。

 

 ### 16、redis主从复制，主从切换，集群

分布式与集中式：

 CAP:C一致性，A可用性，P分区容错性。这三个基本需求，最多能满足两个。

BASE: 基本可用，软状态，最终一致性。

 

分布式锁：惯用关系数据库固有的排他性实现不同进程之间的互斥，但关系数据库瓶颈所在，别啥都交给人家。

redis的SETNX命令可以方便的实现分布式锁。 setNX（SET if Not eXists）+ expire;

如果是为了效率(efficiency)而使用分布式锁，允许锁的偶尔失效，那么使用单Redis节点的锁方案就足够了，简单而且效率高；如果是为了正确性(correctness)在很严肃的场合使用分布式锁，那么不要使用Redlock；应该考虑类似Zookeeper的方案，或者支持事务的数据库。

1.获取当前时间戳

2.client尝试按照顺序使用相同的key,value获取所有redis服务的锁，在获取锁的过程中的获取时间比锁过期时间短很多，这是为了不要过长时间等待已经关闭的redis服务。并且试着获取下一个redis实例。

比如：TTL为5s,设置获取锁最多用1s，所以如果一秒内无法获取锁，就放弃获取这个锁，从而尝试获取下个锁

3.client通过获取所有能获取的锁后的时间减去第一步的时间，这个时间差要小于TTL时间并且至少有3个redis实例成功获取锁，才算真正的获取锁成功

4.如果成功获取锁，则锁的真正有效时间是 TTL减去第三步的时间差 的时间；比如：TTL 是5s,获取所有锁用了2s,则真正锁有效时间为3s(其实应该再减去时钟漂移);

5.如果客户端由于某些原因获取锁失败，便会开始解锁所有redis实例；因为可能已经获取了小于3个锁，必须释放，否则影响其他client获取锁

 

Zookeeper分布式锁：

竞争分布式锁，在一个节点下，创建临时序列节点，找出最小的序列节点，获取分布式锁，程序执行完成之后此序列节点消失，通过watch来监控节点的变化，从剩下的节点的找到最小的序列节点，获取分布式锁，执行相应处理，依次类推……

 

​    架构相关

主从+哨兵：

​    通过持久化功能，Redis能把内存中数据保存到硬盘上，保证了即使在服务器重启的情况下也不会损失（或少量损失）数据。数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上。Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库[1] （slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。

​    当从数据库启动时，会向主数据库发送sync命令，主数据库接收到sync后开始在后台保存快照rdb，在保存快照期间受到的命令缓存起来，当快照完成时，主数据库会将快照和缓存的命令一块发送给从数据库。从数据库依据快照和命令和主节点保持同步。之后，主每受到1个命令就同步发送给从数据库。

当出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库、增量复制。

master每次接收到写命令之后，先在内部写入数据，然后异步发送给slave node

如果采用了主从架构，那么建议必须开启master node的持久化！否则重启之后，认为自己没有数据，会把从节点清空，丢失数据。

slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量。

Slave node不会设置过期key，如果主节点一个key过期了，或者通过LRU淘汰了一个key,发送del命令给从节点。

master和slave都要知道各自的数据的offset，才能知道互相之间的数据不一致的情况。

 

哨兵：

Redis 2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。

哨兵的作用就是监控redis主、从数据库是否正常运行，主出现故障自动将从数据库转换为主数据库。

  （1）监控主数据库和从数据库是否正常运行。 

（2）主数据库出现故障时自动将从数据库转换为主数据库。

主从切换过程：

（1） slave leader升级为master 

（2） 其他slave修改为新master的slave 

（3） 客户端修改连接 

（4） 老的master如果重启成功，变为新master的slave

1、两种数据丢失的情况

（1）异步复制导致的数据丢失，数据还没复制到slave，master就宕机了。

（2）脑裂导致的数据丢失。集群里就会有两个master，

解决方法：要求至少有1个slave，数据复制和同步的延迟不能超过10秒

如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝客户端的写请求。

哨兵：sdown是主观宕机，就一个哨兵如果自己觉得一个master宕机了，那么就是主观宕机

​     odown是客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，那么就是客观宕机。

如果一个master被认为odown了，而且majority哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，

接下来会对slave进行排序

（1）按照slave优先级进行排序，slave priority越低，优先级就越高

（2）如果slave priority相同，那么看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高

（3）如果上面两个条件都相同，那么选择一个run id比较小的那个slave

集群：

主从架构+哨兵机制虽然保证了Redis的高可用性，但每个Redis实例都是全量保存，浪费内存。为了最大化的利用内存，可以使用集群，也就是分布式存储，每台redis存储不同的内容。

Reids分布式数据存储算法不是一致性哈希，而是哈希槽算法。

redis cluster有固定的16384个hash slot，对每个key计算CRC16值，然后对16384取模，可以获取key对应的hash slot。

redis cluster中每个master都会持有部分slot，比如有3个master，那么可能每个master持有5000多个hash slot。

hash slot让node的增加和移除很简单，增加一个master，就将其他master的hash slot移动部分过去，减少一个master，就将它的hash slot移动到其他master上去。移动成本很低。

Redis集群集成了主从复制和哨兵的功能。集群支撑N个redis master node，每个master node都可以挂载多个slave node

读写分离的架构，对于每个master来说，写就写到master，然后读就从mater对应的slave去读。

高可用，因为每个master都有salve节点，那么如果mater挂掉，redis cluster这套机制，就会自动将某个slave切换成master。redis cluster（多master + 读写分离 + 高可用）；

 

在redis cluster架构下，每个redis要放开两个端口号，比如一个是6379，另外一个就是加10000的端口号，比如16379。16379端口号是用来进行节点间通信的，也就是cluster bus的东西，集群总线。cluster bus的通信，用来进行故障检测，配置更新，故障转移授权。

 

集群是如何判断是否有某个节点挂掉：

​    每一个节点都存有这个集群所有主节点以及从节点的信息。它们之间通过互相的ping-pong判断是否节点可以连接上。如果有一半以上的节点去ping一个节点的时候没有回应，集群就认为这个节点宕机了，然后去连接它的备用节点。

集群进入fail状态的必要条件：

​    1、某个主节点和所有从节点全部挂掉，我们集群就进入faill状态。

​    2、如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态.

​    3、如果集群任意master挂掉,且当前master没有slave.集群进入fail状态。

​    主节点宕机之后，从节点发起投票，投票过程是集群中所有master参与。选举的依据依次是：网络连接正常->5秒内回复过INFO命令->10*down-after-milliseconds内与主连接过的->从服务器优先级->复制偏移量->运行id较小的。









## 手撕代码

### 1. 三大排序

​    排序：快速，归并，堆排序

​                               

  //快速排序,快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。

  // 快速排序、堆排序、希尔排序等时间性能较好的排序方法都是不稳定的。稳定性需要根据具体需求选择。

  // 先从序列中取出一个数作为基准数；先选择数组的最左边;

  //分区过程：将把这个数大的数全部放到它的右边，小于或者等于它的数全放到它的左边；

  //递归地对左右子序列进行不走2，直到各区间只有一个数

  private static void quickStart(int[] arr,int left, int right){

​    if(arr == null || left >= right || arr.length < 1)

​    return;

​    int mid = partition(arr,left,right);

​    quickStart(arr,left,mid-1);

​    quickStart(arr,mid+1,right);

  }

  private static int partition(int[] arr, int left, int right){

​    int pivotKey = arr[left];

 

​    while(left < right) {

​      while(left < right && arr[right] >= pivotKey)

​        right --;

​      arr[left] = arr[right]; //把小的移动到左边

​      while(left < right && arr[left] <= pivotKey)

​        left ++;

​      arr[right] = arr[left]; //把大的移动到右边

​    }

​    arr[left] = pivotKey; //最后把pivot赋值到中间

​    return left;

   }

 

  private static void swap1(int[] arr, int left, int rihgt){

​    int temp = arr[left];

​    arr[left] = arr[rihgt];

​    arr[rihgt] = temp;

  }

 

  //归并排序：

  //二路归并排序，让数组分成2组，然后递归多分几组，知道每组只有一个，然后对每2有序小组进行排序合并。

  //归时，要创建新数组，暂存结果

  public static int[] sortMerge(int[] array,int left,int right){

​    int mid = left + (right-left)/2;

​    if (left < right){

​      sortMerge(array,left,mid);

​      sortMerge(array,mid+1,right);

​      merge(array,left,mid,right);

​     }

​    return array;

  }

 

  //将有序的left-mid和mid+1 --- right这两个有序数组排序;

  public static void merge(int[] array,int left,int mid,int right){

​    //String s = "sdd";

​    //s.indexOf()

​    int[] temp = new int[right-left+1];

​    int i = left;

​    int j = mid +1;

​    int k = 0;

​      while (i<=mid && j <= right){

​        if (array[i] < array[j])

​          temp[k++] = array[i++];

​        else

​          temp[k++] = array[j++];

​    }

​    while (i <= mid)

​       temp[k++] = array[i++];

​    while (j<=right)

​      temp[k++] = array[j++];

 

​    for(int x=0;x<temp.length;x++){

​      array[x+left] = temp[x];

​    }

  }



### 2.

集合重复问题:

​    位图法：集合的最大元素max,创建max+1的数组，如果遇到元素5，设nums[6] = 1,下次还这样时，如果nums[i]=1,表示已经存在。还可以排序。

​    布隆过滤器：检测一个元素是否属于一个集合。当他不属于这个集合时，那一定数不属于的。如果判断属于，那不一定。实现原理:位数组和Hash结合。M位的位数组，初始化为0.定义k个不同的hash函数，每个函数都将集合中的元素映射到位数组的一位。向集合中插入元素时，k个哈希得到k位。将这些位设为1.

​    新的被检测元素时，看这k位是否全为1.有一个为0，说明不在集合中。

​    

TOPK问题：

​    最小堆，建立一个最小堆。一个个遍历。中序遍历最终的最小堆；mlogm建堆m大小。 时间复杂度nmlogm

​    分治：将大文件分成小文件，每个小文件用快排算出topk, 然后合并一块求topk.

频率TOPK, 将数据集按照hash的方法分解成多个小数据集，然后用trie或者hash统计每个小数据集的频率，然后用小顶堆算出每个数据集中出现频率最高的K个，然后算出所有的topK.

去重：

​    位图法： 9位数的话，99999999+1大小的位数组。

排序问题：

​    数据库排序法：文本文件导入数据库，数据库索引排序。

​    分治法：分治排序，然后集合。

​    位图法：形成max+1的位数组，填入，然后从大到小开始排



---

String是怎么扩容的（不知道，后来查的：2倍扩容，超出1M后每次扩大1M）

为什么会出现 4.0-3.6=0.40000001 这种现象？

​    2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。



ArrayList 和 LinkedList 区别？三种方式访问集合中的元素，ArrayList遍历删除会出的问题？Foreach原理以及Fail-fast机制！

为什么会出现 4.0-3.6=0.40000001 这种现象？

为什么HashMap长度大于8才转换为红黑树，而不是6？

HashMap和TreeMap比较？

任务缓存队列及排队策略，如何自定义拒绝策略？

配置线程池大小，根据CPU密集和IO密集划分

阻塞队列以及生产者消费者的实现

设计模式的单例和工厂是面得最多的

为什么需要破坏双亲委派？自己写个String能加载吗？类初始化时机？

JVM调优

Redis 的缺点？

Redis的并发竞争问题如何解决？

集群是如何判断是否有某个节点挂掉？集群进入fail状态的必要条件？

减库存然后下订单，但是服务器宕机？

负载均衡实现方式，策略？

单拎出来的缓存问题，结合状态码 304 可能问到，相关头字段，**If-Modified-Since** **和** **Last-Modified****，****If-None-Match** **和** **ETag****，它们的区别等；**

有序性的先行发生原则（happens-before）。

虚引用有哪些应用场景

介绍下JDBC的过程

JDBC的Statement对象有哪几类



int和Integer有什么区别

​    为了编程方法， Java有八大基本数据类型。又为了能将这些基本数据类型当做对象处理，又为每个基本数据类型引入了对应的包装类型。JDK1.5之后，引入自动拆箱机制，基本数据类型和包装类可以互换。

​    Integer是int的包装类，必须实例化为才能使用，Integer变量实际是对象的引用，指向对象，默认值为null;

​    int是基本数据类型,不必实例化就能用，它直接存数据值，默认是0.

​    Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true。因为自动拆箱。

​    非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。

​    对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false。

​    Integer缓存池大小：-128 ----127























 

